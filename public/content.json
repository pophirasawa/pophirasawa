{"meta":{"title":"PopHirasawa's Blog","subtitle":"循此苦旅，直抵群星。","description":"","author":"PopHirasawa","url":"https://pophirasawa.top","root":"/"},"pages":[{"title":"categories","date":"2021-10-29T10:05:49.000Z","updated":"2021-10-29T11:06:46.569Z","comments":true,"path":"categories/index.html","permalink":"https://pophirasawa.top/categories/index.html","excerpt":"","text":""},{"title":"Pophirasawa","date":"2021-10-29T09:21:07.000Z","updated":"2021-10-31T08:54:23.820Z","comments":true,"path":"about/index.html","permalink":"https://pophirasawa.top/about/index.html","excerpt":"","text":"不知道浪费了多少时间，又下定决心好好学习了？ 在此之前，有没有考虑过再看一遍轻音少女呢。"},{"title":"My Friends' Blogs","date":"2021-11-04T05:52:29.000Z","updated":"2022-03-22T13:01:27.596Z","comments":true,"path":"links/index.html","permalink":"https://pophirasawa.top/links/index.html","excerpt":"","text":"有没有一种可能，以下的都是超人捏 确实 Jnnnn：POPCHICKEN’s Blog 蘑菇：Mushroom323’s Blog Heye：Heyewuyue1’s Blog F0：Ibukifalling’s Blog 伞哥：Fohunbrella’s Blog Bangg：Banned’s Blog TonyZhao：TonyZhao’s Blog WA_Automaton:WA_Automaton’s Blog 孙老师：香芋派Taro’s Blog 山荷叶: 0x39.me 山阳子瑜: 鱼籽 mhy: mhy 石上: 石上 RuaYiii: Rua宝 Poria: Poria"},{"title":"tags","date":"2021-10-29T10:04:25.000Z","updated":"2021-10-29T11:06:16.405Z","comments":true,"path":"tags/index.html","permalink":"https://pophirasawa.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"回文树","slug":"01或许是算法/回文树","date":"2022-03-22T14:06:26.000Z","updated":"2022-03-22T15:19:02.083Z","comments":true,"path":"2022/03/22/01或许是算法/回文树/","link":"","permalink":"https://pophirasawa.top/2022/03/22/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%96%87%E6%A0%91/","excerpt":"久违的学一点点东西得了。。。 简而言之 回文树是一种用来处理回文的自动机,可以处理一个字符串中的所有不同子串 指路论文：https://victorwonder.blog.uoj.ac/blog/146","text":"久违的学一点点东西得了。。。 简而言之 回文树是一种用来处理回文的自动机,可以处理一个字符串中的所有不同子串 指路论文：https://victorwonder.blog.uoj.ac/blog/146 首先 我们有这么一个结论： 一个长为n字符串中最多存在n个本质不同的回文子串 每次加入一个字符，假设生成了1个以上的本质不同回文子串 考虑生成的最长的和最短的回文子串A、B，那么有两种可能 B的左端点在A的中点右边：由于B为回文串，则A中点左侧必定存在一个与B相同的回文串，矛盾 B的左端点在A的中点左边：由于A为回文串，则B截去超出中点的镜像部分在A中点左侧必定存在相同的串，矛盾 因此每次加入一个字符生成本质不同回文子串最多一个 然后 我们就可以开始构造这个回文树了 如果这个图没有挂的话， 我们可以看出，这个玩意和sam啥的都很像，就是由转移边和fail指针（后缀link）组成的。 两个起始状态奇根和偶根就是用来存长度为奇数的回文串和长度为偶数的回文串 后缀link就是指向当前回文串的最长回文后缀。 具体 和那些奇奇怪怪的自动机一样，我们每次都加入一个字符。 假设已经处理了的串为s，我们要加入一个新的字符X，那么该怎么办呢？ 首先我们找到串s的最长后缀回文串t（这玩意已经提前维护好了） 那么如果s的最后一段长成xtx这样，那么显然这玩意就是新串的最长回文后缀，然后我们还可以试图更新一下状态啥的 那如果不是呢 聪明的你一定想到了：肯定要用到后缀link呗， 不然哥们维护他干嘛 确实，只要找t的后缀link到的各个节点，一个个试即可，最后大不了到奇根。变成长度为1的回文子串即可。 一个小问题： 新出现的状态后缀link该往哪里连？ 很显然，新状态的最长回文后缀也是Xt’X的形式，从新出现的状态接着往下找一找就完事了 这个理论上应该存在的图就很好的说明了整个流程 最后 喜闻乐见的代码时间！ 板子，开超！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct PAM&#123; int nex[maxn][26]; //指向的一个字符的节点 int fail[maxn]; //失配节点 int len[maxn]; //当前节点回文长度 int str[maxn]; //当前字符串 int cnt[maxn]; //节点出现次数 int last; //目前走到哪个节点 int tot; //PAM中节点数 int N; //添加的串的个数 int newnode(int L)&#123; //新建节点 for(int i = 0; i &lt; 26; i++) nex[tot][i] = 0; len[tot] = L; cnt[tot] = 0; return tot++; &#125; void init()&#123; tot = 0; newnode(0); newnode(-1); last = 0; N = 0; str[0] = -1; fail[0] = 1; //偶根指向奇根，因为到奇根必匹配 &#125; int getfail(int x)&#123; //失配 while(N - len[x] - 1 &lt; 0 || str[N - len[x] - 1] != str[N]) x = fail[x]; return x; &#125; void add(char ss)&#123; int c = ss - &#x27;a&#x27;; str[++N] = c; int cur = getfail(last); //最长可扩增的后缀回文节点 if(!nex[cur][c])&#123; int now = newnode(len[cur] + 2); fail[now] = nex[getfail(fail[cur])][c]; //cur后缀(除自己)的最长的能让now失配的后缀 nex[cur][c] = now; &#125; last = nex[cur][c]; cnt[last]++; &#125; void count()&#123; for(int i = tot - 1; i &gt;= 0; i--) //子节点出现父节点也出现 cnt[fail[i]] += cnt[i]; &#125;&#125;pam;","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"回文","slug":"回文","permalink":"https://pophirasawa.top/tags/%E5%9B%9E%E6%96%87/"}]},{"title":"2022 winter training 1-H","slug":"03久远时光以前的补题记录/寒假补题1-H","date":"2022-01-12T10:23:23.000Z","updated":"2022-01-12T10:32:52.631Z","comments":true,"path":"2022/01/12/03久远时光以前的补题记录/寒假补题1-H/","link":"","permalink":"https://pophirasawa.top/2022/01/12/03%E4%B9%85%E8%BF%9C%E6%97%B6%E5%85%89%E4%BB%A5%E5%89%8D%E7%9A%84%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%AF%92%E5%81%87%E8%A1%A5%E9%A2%981-H/","excerpt":"摆了，但是没有完全摆 CF103495H H. Reverse the String 给定长1e5的字符串，你可以翻转其中一段连续子段，问能产生的字典序最小的字符串是啥 据说可以用SA写，我是没啥思路，题解是hash，就这样补了","text":"摆了，但是没有完全摆 CF103495H H. Reverse the String 给定长1e5的字符串，你可以翻转其中一段连续子段，问能产生的字典序最小的字符串是啥 据说可以用SA写，我是没啥思路，题解是hash，就这样补了 思路 考虑把字符串的字符排序，生成的新字符串必然是字典序最小的构造。 那么我们从原字符串和新字符串第一个不同的点作为翻转的起点即可。 然后枚举右端点，通过二分hash，求lcp来比较字符串大小即可。 hash的话，正反跑一遍拼起来就完了，不过式子有一点折磨捏 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;unordered_map&gt;#include &lt;iomanip&gt;#include&lt;set&gt;typedef long long ll;typedef unsigned long long ull;using namespace std;char s[200000 + 5];char s2[200000 + 5];ll seed = 20111203;ll mod = 1e9 + 7;ll T;ll h[200000 + 5];ll r[200000 + 5];ll poww[200000 + 5];ll l;ll q(ll L, ll R, ll x) &#123; if (x &lt; L)return h[x]; if (x &gt; R)return ((h[L - 1] * poww[x - L + 1])%mod +(r[L] - r[R+1] * poww[R - L + 1]%mod+mod)%mod * poww[x - R]%mod + (h[x] - (ull)h[R] * poww[x - R]%mod +mod)%mod)%mod; else return (h[L - 1] * poww[x - L + 1]%mod + (r[R-(x-L)] - r[R+ 1] * poww[(x - L)+1]%mod+mod)%mod)%mod;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(NULL); poww[0] = 1; for (int i = 1; i &lt;= 100000 + 5; i++) &#123; poww[i] = poww[i - 1] * seed%mod; &#125; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; s + 1; l = strlen(s+1); for (int i = 1, j = l; i &lt;= l &amp;&amp; j &gt;= 1; i++,j--) &#123; h[i] =( h[i - 1] * seed%mod + s[i] - &#x27;a&#x27;)%mod; r[j] = (r[j + 1] * seed%mod + s[j] - &#x27;a&#x27;)%mod; s2[i] = s[i]; &#125; sort(s2 + 1, s2 + 1 + l); ll r1 = 0; for (int i = 1; i &lt;= l; i++) &#123; if (s[i] == s2[i])r1 = i; else break; &#125; r1++; //cout &lt;&lt; q(2, 4, 2); if (r1 &gt; l)cout &lt;&lt; s + 1 &lt;&lt; &#x27;\\n&#x27;; else &#123; ll mx = r1; for (int i = r1; i &lt;= l; i++) &#123; ll L = 0, R = l; while (L&lt;R) &#123; ll m = L + R &gt;&gt; 1; if (q(r1, i, m) == q(r1, mx, m))L = m+1; else R = m; &#125; if (L &gt; l)continue; if (q(r1, i, L) &lt; q(r1, mx, L))mx = i; &#125; for (int i = 1; i &lt; r1; i++)cout &lt;&lt; s[i]; for (int i = mx; i &gt;= r1; i--)cout &lt;&lt; s[i]; for (int i = mx + 1; i &lt;= l; i++)cout &lt;&lt; s[i]; cout &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;","categories":[{"name":"补题","slug":"补题","permalink":"https://pophirasawa.top/categories/%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://pophirasawa.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Super Star Spectacle","slug":"A","date":"2022-01-11T17:09:00.000Z","updated":"2022-01-11T17:16:50.241Z","comments":true,"path":"2022/01/12/A/","link":"","permalink":"https://pophirasawa.top/2022/01/12/A/","excerpt":"","text":"列车一定会去往下一站，而舞台少女，将会前往下个舞台。","categories":[],"tags":[]},{"title":"wi(l)d-screen baroque","slug":"Q","date":"2022-01-11T16:52:30.000Z","updated":"2022-01-11T17:31:33.217Z","comments":true,"path":"2022/01/12/Q/","link":"","permalink":"https://pophirasawa.top/2022/01/12/Q/","excerpt":"","text":"列车一定会去往下一站。那么舞台呢？我们呢？","categories":[],"tags":[]},{"title":"鸽巢原理","slug":"04学习/鸽巢原理","date":"2022-01-09T17:10:00.000Z","updated":"2022-01-19T03:04:46.726Z","comments":true,"path":"2022/01/10/04学习/鸽巢原理/","link":"","permalink":"https://pophirasawa.top/2022/01/10/04%E5%AD%A6%E4%B9%A0/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/","excerpt":"内容 鸽巢原理及其一些推论，包括但不限于 简单形式 中国剩余定理 加强形式 Ramesy定理 呃呃","text":"内容 鸽巢原理及其一些推论，包括但不限于 简单形式 中国剩余定理 加强形式 Ramesy定理 呃呃 简单形式 n+1个物品放入n个盒子中，至少存在一个盒子中存在多个物品 可以抽象表示为: 令X，Y为两有限集，令f为一个从X到Y的函数 若X的元素大于Y的元素，则f不是一对一的 若X和Y有相同个数的元素，且f是映上的，则f是一对一的 若X和Y有相同个数的元素，且f是一对一的，则f是映上的 然后就可以发展出一些应用了 推论：中国剩余定理 令m和n为互素的正整数，有正整数a、b，且a不大于m-1，b不大于n-1。则存在x，x mod m = a，x mod n = b。 证明：先得出在a，a+m，a+2m，…(n-1)m+a中mod n没有相同的余数。因此n个数中0到n-1每个数都作为余数出现。那对与b也存在对应的p令pm+a mod n = b Ramsey定理 在6个人中，或有三个人他们彼此互相都认识，或有三个人，他们中两两都彼此不认识。 也就是说： 考虑一个6个点的无向完全图，将边染成两种颜色。那么必定存在一个三角形三条边为相同的颜色。 也可以表示为K6→K3,K3也可以表示为K_6\\rightarrow K_3,K_3 也可以表示为K6​→K3​,K3​ 更一般的定义如下： m，n为两个不小于2的整数，那么将存在一个正整数p，令$$K_P \\rightarrow K_m,K_n$$ Ramsey数r(m,n)为令等式成立的最小整数p 有定理 r(2,n)=n以及r(m,2)=m 可以往更高维推广。。。","categories":[{"name":"组合数学","slug":"组合数学","permalink":"https://pophirasawa.top/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Goodbye 2021","slug":"03久远时光以前的补题记录/2021-01-6","date":"2022-01-06T14:33:22.000Z","updated":"2022-01-06T17:13:10.130Z","comments":true,"path":"2022/01/06/03久远时光以前的补题记录/2021-01-6/","link":"","permalink":"https://pophirasawa.top/2022/01/06/03%E4%B9%85%E8%BF%9C%E6%97%B6%E5%85%89%E4%BB%A5%E5%89%8D%E7%9A%84%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/2021-01-6/","excerpt":"2021年就这么结束了，不管是失败还是悲伤还是焦虑，亦或者是欢乐还是欣喜还是怀念，都已经过去了。 可能会写点文字来怀念？ 不过现在应该做的事情只有一件 补题。","text":"2021年就这么结束了，不管是失败还是悲伤还是焦虑，亦或者是欢乐还是欣喜还是怀念，都已经过去了。 可能会写点文字来怀念？ 不过现在应该做的事情只有一件 补题。 D. Keep the Average High 将式子变形一下 al+al+1+…+ar≥x⋅(r−l+1)⇒(al−x)+(al+1−x)+…+(ar−x)≥0a_l + a_{l+1} + \\ldots + a_r \\geq x \\cdot (r - l + 1) \\Rightarrow (a_l - x) + (a_{l+1} - x) + \\ldots + (a_r - x) \\geq 0al​+al+1​+…+ar​≥x⋅(r−l+1)⇒(al​−x)+(al+1​−x)+…+(ar​−x)≥0 然后就是挑一些最多的数让他满足所有连续子段和非负 然后就有一个很nb的结论 要满足上边的条件 只需要所有长度为2和3的子段满足条件即可 可以这样考虑： 所有长度大于2或者3的子段都可以拆成一些2和3不相交子段的和 稍微想一下奇偶应该就可以懂了 然后我们是不是就可以用用DP了呢（ 1dp[N][2][2];//dp数组，第一位表示到第i个能选的最大数量，第二位表示前一个有没有选，第三位表示当前位有没有选 转移就直接看代码吧 巨巧妙 反正我这个智力是不太能想到的（ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;unordered_map&gt;typedef long long ll;using namespace std;ll T;ll n;ll x;ll dat[50000 + 5];ll dp[50000 + 5][2][2];int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; dat[i]; cin &gt;&gt; x; for (int i = 0; i &lt; n; i++)dat[i] -= x; memset(dp, 0, sizeof(dp)); dp[0][0][1] = 1; for (int i = 1; i &lt; n; i++) &#123; dp[i][0][0] = max(dp[i - 1][0][0], dp[i - 1][1][0]); dp[i][0][1]=1LL+ max(dp[i - 1][0][0], dp[i - 1][1][0]); dp[i][1][0] = max(dp[i - 1][0][1], dp[i - 1][1][1]); if (dat[i - 1] + dat[i] &gt;= 0) &#123; dp[i][1][1] = 1LL + dp[i-1][0][1]; if (i &gt; 1 &amp;&amp; dat[i - 2] + dat[i - 1] + dat[i] &gt;= 0) &#123; dp[i][1][1] = max(dp[i][1][1], 1 + dp[i - 1][1][1]); &#125; &#125; &#125; ll ans = max(dp[n - 1][0][0], max(dp[n - 1][0][1], max(dp[n - 1][1][0], dp[n - 1][1][1]))); printf(&quot;%lld\\n&quot;, ans); &#125;&#125; E. Lexicographically Small Enough 这B题说简单不简单，说难不难 但是我看题解都想了好久 我是废物！ 给你个字符串s和字符串t 可以交换相邻的s字符，问最少次数令s字典序比t小 其实他的本质就是让s按照某种意义重新排序，然后问冒泡排序的交换次数呗 用树状数组维护逆序对 然后对于每个t[i]我们有两种思路 一种是直接从i后边拉一个比t[i]小的字符直接结束 一种是拉一个最近的和t[i]一样的字符 维护一个cur是到当前令其前缀相同的花费 然后我从后边拉字符他的花费其实就是逆序对 我们就可以跑贪心了 也许 这玩意数据太大了 ans设成1e9+7居然都会挂掉 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;unordered_map&gt;typedef long long ll;using namespace std;ll T;ll n;ll x;vector&lt;ll&gt;pos[26];ll sum[100000 + 5];char s[100000 + 5], t[100000 + 5];ll lob(ll i) &#123; return i &amp; -i;&#125;void init() &#123; for (int i = 0; i &lt;= n; i++)sum[i] = 0;&#125;void add(ll i) &#123; for (; i &lt; n; i = i | (i + 1)) &#123; sum[i] += 1; &#125;&#125;ll q(ll i) &#123; ll res = 0; for (;i&gt;=0; i=(i &amp; (i + 1)) - 1) res += sum[i]; return res;&#125;int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; init(); cin &gt;&gt; s&gt;&gt;t; for (int i = 0; i &lt; 26; i++)pos[i].clear(); for (int i = 0; i &lt;n; i++)pos[s[i] - &#x27;a&#x27;].push_back(i); for (int i = 0; i &lt; 26; i++)reverse(pos[i].begin(),pos[i].end()); ll ans = 1e11 + 7; ll cur = 0; for (int i = 0; i &lt;n; i++) &#123; ll c = t[i] - &#x27;a&#x27;; ll m = 1e11+7; for (int j = 0; j &lt; c; j++) &#123; if (pos[j].empty())continue; m = min(m, pos[j].back()); &#125; if (m &lt;n) ans = min(ans, cur + m - q(m)); if (pos[c].empty())break; m = pos[c].back(); cur += m - q(m); pos[c].pop_back(); add(m); &#125; if (ans == 1e11 + 7)printf(&quot;-1\\n&quot;); else printf(&quot;%lld\\n&quot;, ans); &#125;&#125;","categories":[{"name":"补题","slug":"补题","permalink":"https://pophirasawa.top/categories/%E8%A1%A5%E9%A2%98/"}],"tags":[]},{"title":"sam相关","slug":"01或许是算法/sam相关题目","date":"2021-11-24T18:43:31.000Z","updated":"2021-11-26T13:09:57.826Z","comments":true,"path":"2021/11/25/01或许是算法/sam相关题目/","link":"","permalink":"https://pophirasawa.top/2021/11/25/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/sam%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/","excerpt":"学完了这阴间玩意肯定得知道这玩意怎么用吧 sam理论上可以 子串endpos大小 子串endpod位置 在后缀link上跑dp 在自动机上跑dp 统计有多少个子串经过一个点 二分","text":"学完了这阴间玩意肯定得知道这玩意怎么用吧 sam理论上可以 子串endpos大小 子串endpod位置 在后缀link上跑dp 在自动机上跑dp 统计有多少个子串经过一个点 二分 然后就是题目呗 P3975 [TJOI2015]弦论 给定字符串，求找到字典序第k大的子串 有两种询问：相同子串就算1个和每个子串都算一个的 首先把endpos大小跑出来 如果相同子串只算1个，那么子串到每个状态的贡献只有1，不然就是endpos大小。endpos大小可以把状态按len排序然后从大到小更新就行。 然后跑一下dfs，统计从点i开始的有多少个字符串 最后按字典序从自动机上跑就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const ll MAXN =6e5 + 500;string s;ll k, t;struct NODE &#123; int ch[26] = &#123;&#125;; ll fa = 0, len = 0; //NODE() &#123; memset(ch, 0, sizeof(ch)); fa = 0, len = 0; &#125;&#125;sam[MAXN &lt;&lt; 1];ll lst = 1, tot = 1;ll f[MAXN &lt;&lt; 1];bool vis[MAXN &lt;&lt; 1];ll sz[MAXN &lt;&lt; 1];ll A[MAXN &lt;&lt; 1];void add(ll c) &#123; ll p = lst; ll np = lst = ++tot; f[np] = 1; sam[np].len = sam[p].len + 1; for (; p &amp;&amp; !sam[p].ch[c]; p = sam[p].fa)sam[p].ch[c] = np; if (!p)sam[np].fa = 1; else &#123; ll q = sam[p].ch[c]; if (sam[q].len == sam[p].len + 1)sam[np].fa = q; else &#123; ll nq = ++tot; sam[nq] = sam[q]; sam[nq].len = sam[p].len + 1; sam[q].fa = sam[np].fa = nq; for (; p &amp;&amp; sam[p].ch[c] == q; p = sam[p].fa)sam[p].ch[c] = nq; &#125; &#125;&#125;ll dfs(ll p) &#123; if (vis[p])return sz[p]; vis[p] = 1; ll tmp = f[p]; for (int i = 0; i &lt; 26; i++) if (sam[p].ch[i]) tmp += dfs(sam[p].ch[i]); return sz[p] = tmp;&#125;void solve(ll p) &#123; if (k &gt; sz[p]) &#123; printf(&quot;%d&quot;, -1); return; &#125; if (k &lt;= f[p])return; k -= f[p]; for (int i = 0; i &lt; 26; i++) &#123; if (!sam[p].ch[i])continue; if (sz[sam[p].ch[i]] &lt; k)k -= sz[sam[p].ch[i]]; else &#123; printf(&quot;%c&quot;, i + &#x27;a&#x27;); solve(sam[p].ch[i]); return; &#125; &#125;&#125;bool cmp(ll &amp;a, ll &amp;b) &#123; return sam[a].len &lt; sam[b].len;&#125;int main() &#123; cin &gt;&gt; s; for (int i = 0; i &lt; s.length(); i++) &#123; add(ll(s[i]) - &#x27;a&#x27;); &#125; scanf(&quot;%lld %lld&quot;, &amp;t, &amp;k); if (t == 0) for (int i = 2; i &lt;= tot; i++)f[i] = 1; else &#123; for (int i = 0; i &lt;= tot; i++)A[i] = i; sort(A + 1, A + tot + 1, cmp); for (int i = tot; i &gt; 0; i--)f[sam[A[i]].fa] += f[A[i]]; &#125; f[1]=f[0] = 0; dfs(1); solve(1);&#125; SPOJ1811 求两个字符串里最长公共子串长度 把s建成后缀自动机 然后把t的前缀挨个加进去，其实就是看t的前缀的后缀能在s里最长是多少 假设当前t加入的字符是c，当前状态是v，若v有c的出边，ans直接++ 如果没有，就一直找v的后缀link到有c的出边为止，ans=len+1了 如果这玩意到了0状态，就把他设回源点状态，ans=0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const ll MAXN = 5e5 + 5;struct NODE&#123; int ch[26] = &#123;&#125;; int len, fa;&#125;sam[MAXN &lt;&lt; 1];ll lst = 1, tot = 1;string s1, s2;void add(ll c) &#123; ll p = lst; ll np = lst = ++tot; sam[np].len = sam[p].len + 1; for (; p &amp;&amp; !sam[p].ch[c]; p = sam[p].fa)sam[p].ch[c] = np; if (!p)sam[np].fa = 1; else &#123; ll q = sam[p].ch[c]; if (sam[q].len == sam[p].len + 1)sam[np].fa = q; else &#123; ll nq = ++tot; sam[nq] = sam[q]; sam[nq].len = sam[p].len + 1; sam[q].fa = sam[np].fa = nq; for (; p &amp;&amp; sam[p].ch[c] == q; p = sam[p].fa)sam[p].ch[c] = nq; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; s1 &gt;&gt; s2; ll ans = 0; for (int i = 0; i &lt; s1.length(); i++)add(s1[i] - &#x27;a&#x27;); ll v = 1, l = 0;; for (int i = 0; i &lt; s2.length(); i++) &#123; ll tmp = s2[i] - &#x27;a&#x27;; if (sam[v].ch[tmp]) &#123; v = sam[v].ch[tmp]; l++; &#125; else &#123; for (; v &amp;&amp; !sam[v].ch[tmp]; v = sam[v].fa); if (v == 0) &#123; l = 0, v = 1; &#125; else &#123; l = sam[v].len + 1; v = sam[v].ch[tmp]; &#125; &#125; ans = max(ans, l); &#125; cout &lt;&lt; ans;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/tags/SAM/"}]},{"title":"后缀自动机","slug":"01或许是算法/sam","date":"2021-11-19T18:08:36.000Z","updated":"2022-01-03T12:59:54.281Z","comments":true,"path":"2021/11/20/01或许是算法/sam/","link":"","permalink":"https://pophirasawa.top/2021/11/20/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/sam/","excerpt":"这玩意就是SAM的原理以及基本板子了，大概，说不定再来一点套路总结吧 总的来说，这玩意拖的也太久了，一直说要学，然后狂摸不止，我 有罪！ 欸嘿","text":"这玩意就是SAM的原理以及基本板子了，大概，说不定再来一点套路总结吧 总的来说，这玩意拖的也太久了，一直说要学，然后狂摸不止，我 有罪！ 欸嘿 介绍 首先后缀自动机 可以包括给定字符串的所有子串 O(n) 是自动机 一些定义 endpos 字符串s的一个子串t，endpos(t)为s中t的所有结束位置构成的集合 SAM是一个最小的DFA 有向无环图 节点是状态，边是转移 转移是一些字母 从源点出发到终止状态所有转移连起来的字符串t是字符串s的一个后缀 SAM的节点最小 那么如果endpos(t1)=endpos(t2)，那么他们就在一个等价类中 一堆引理 两个非空子串u，w (|u|&lt;=|w|) endpos相同，只有u在s中每次出现都是以w的后缀出现的 那么就可以推出来： 考虑u，w (|u|&lt;=|w|) 只有2种可能 endpos(u),endpos(w)不相交 endpos(w)是endpos(u)的子集 一个endpos等价类里边，所有子串长度不同，而且差值为1，正好覆盖区间 然后就有我们的后缀link 对于一个不是源点的状态v，然后考虑这个endpos等价类中最长的字符串w，其他的就是w后缀了捏 然后我们有 w开始，有一个连续区间长度的后缀也都是这个等价类里边的玩意，定义最长的一个不是等价类里边的后缀为t，把v的后缀link到t上 显然最后是link到源点的 最后这玩意就构成了一个树 然后我们就可以开始算法本身了捏 算法实现 哥们看不懂捏 首先说重点 后缀link树和后缀自动机共同相同的节点，不同的只是转移的边不同 大概步骤 首先，这个是在线算法，我们每次往自动机里加入一个字符，然后维护SAM 首先定义初始状态 这个点编号0，len=0，fa=0 然后我们就能挨个加入字符c了 有以下流程 首先我们加入了一个新字符，那么新串对应的的endpos是新的长度，以前不存在，因此我们新建一个状态np，之前整个旧串对应的状态记为p，很显然len(q)=len§+1 然后对于新加入的字符c，我们进行以下操作 如果p没有一个字符c的出边(这里是自动机的边)，就在link树上到他的父节点，也就是后缀link的点，一直循环直到p到达初始状态的节点或者有一个字符c的出边 这个操作其实是压缩遍历旧串的所有后缀x，然后看是否存在一个x+c在旧串种就存在了，因为引理中已经提到，每个状态link到的节点都是当前状态的后缀，所有我们从p上来肯定是旧串的后缀了捏 途中我们把经过每个没有c出边的p都连一个c到np 然后我们就有3种情况 Case 1 p到初始状态都没有c的出边 np状态直接link到初始状态 Case 2 找到了一个p，有c的出边，到达一个新状态q，且len( q )=len( p )+1 首先我们知道p是旧串后缀，q是p的字符串+c，因此q是新串的后缀，那么我们理所当然把np link 到q上就行了 Case 3 和case2差不多，但是找到的p出边到达的q没有len( q )=len( p )+1 或者说，len( q )&gt;len( q )+1 这时候我们要把q拆成两个点，是新串后缀的和不是的，然后link就行 具体来说，定义一个新点nq，len=len§+1,出边转移和q相同，link 到p上，然后np和q都link到nq上 最后稍微更新下转移边，p往上走，把所有p link 到q的转移 link 到nq上就行了 最后稍微提一下如何计算每个状态的endpos大小 设想一下，我们每次加入一个字符c，肯定会出现一个新的endpos，而且他能够对往上走到源点经过的所有节点都产生影响，也就是说我们使用一个数组f[i]来统计endpos，加入新字符时让f[np]=1,最后跑一下dfs，f[i]=f[i]+sum(f[i所有的儿子]) 即可捏 或者把sam的点按len排序(可以用桶排) 从大到小更新 **f[sam[i].fa]+=f[i]**也行 code 先贴一手毛的板子 1234567891011121314151617181920212223242526struct NODE&#123; int ch[26]; int len,fa; NODE()&#123;memset(ch,0,sizeof(ch));len=0;&#125;&#125;sam[MAXN&lt;&lt;1];int lst=1,tot=1;void add(int c)&#123; int p=lst;int np=lst=++tot; sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa)sam[p].ch[c]=np; if(!p)sam[np].fa=1;//以上为case 1 else &#123; int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1)sam[np].fa=q;//以上为case 2 else &#123; int nq=++tot;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa)sam[p].ch[c]=nq;//以上为case 3 &#125; &#125;&#125; 暂时先写这么多，乏了，早上写一手题以及用法吧","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/tags/SAM/"}]},{"title":"维护区间众数","slug":"01或许是算法/维护区间众数","date":"2021-11-10T09:32:12.000Z","updated":"2021-11-16T15:34:34.532Z","comments":true,"path":"2021/11/10/01或许是算法/维护区间众数/","link":"","permalink":"https://pophirasawa.top/2021/11/10/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/","excerpt":"这玩意好像方法挺多的，然后今天被一个阴间东西坑了，来说一哈 其实就是给一个数列，然后给一堆询问，问你区间众数是多少吧","text":"这玩意好像方法挺多的，然后今天被一个阴间东西坑了，来说一哈 其实就是给一个数列，然后给一堆询问，问你区间众数是多少吧 首先先把我之前的复制一手啊 绝对众数问题 就是出现个数超过n/2的众数 这个我们可以用一个摩尔投票的方法来写捏 摩尔投票 首先考虑一个序列，里面两两取数，如果一样就留下，不一样就两个数都消掉，那么最后留下的数肯定就是数量超过n/2的数 实现的话，用两个变量cur和cnt，如果当前的数和cur不同且cnt==0 cur变为当前数，否则cnt– 如果相同 cnt++ 最后cur就是唯一有可能是绝对众数的数，然后跑一遍确认即可 123456789101112ll dat[maxn];ll majorityElement()&#123; ll cnt=1,cur=dat[0]; for(int i=1;i&lt;n;i++)&#123; if(dat[i]!=cnt)cnt--; else cnt++; if(cnt&lt;0)&#123; cut=dat[i]; cnt=0; &#125; &#125;&#125; 如果是n/3以至于n/k 其实就是设置多组cur和cnt就行 然后我们就能用线段树来维护了捏 线段树维护 无论如何产生的绝对众数唯一可能就是左右子区间cur中的一个 如果cur1==cur2 新的区间cur3=cur1 ，cnt3=cnt1+cnt2 如果不同 cur3为两段中cnt较大的一个，且cnt3为两段之差 然后查的时候只要查出来cur然后跑一遍二分查区间内个数就能确定了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct node&#123; ll num, c;&#125;;ll n, q, k;node dat[300001&lt;&lt;2];ll a[300000 + 5];ll l, r;vector&lt;ll&gt; pos[300000 + 5];node merge(node x, node y) &#123; if (x.num == y.num) return(x.num, x.c + y.c); else if (x.c &lt; y.c) return&#123; y.num,y.c - x.c &#125;; else return &#123; x.num,x.c - y.c &#125;;&#125;void pushup(ll o) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; dat[o] = merge(dat[ls], dat[rs]);&#125;void build(ll o, ll l, ll r) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (l == r) &#123; dat[o] = &#123; a[l],1 &#125;; return; &#125; ll m = l + r &gt;&gt; 1; build(ls, l, m); build(rs, m + 1, r); pushup(o);&#125;node ask(ll o, ll l, ll r, ll p, ll q) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (p&lt;= l &amp;&amp; q &gt;= r)return dat[o]; ll m = l + r &gt;&gt; 1; if (q &lt;= m)return ask(ls, l, m, p, q); if (p &gt; m)return ask(rs, m + 1, r, p, q); return merge(ask(ls, l, m, p, q), ask(rs, m + 1, r,p, q));&#125;int main() &#123; cin.sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n&gt;&gt;q; srand(time(NULL)); ll tmp; for (int i = 1; i &lt;=n; i++) &#123; cin &gt;&gt; a[i]; pos[a[i]].push_back(i); &#125; build(1, 1, n); for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; l &gt;&gt; r; ll tmp=ask(1, 1, n, l, r).num; ll ans = upper_bound(pos[tmp].begin(), pos[tmp].end(), r) - lower_bound(pos[tmp].begin(), pos[tmp].end(), l); &#125;&#125; 一般的众数 这玩意方法就可多了，这里讲一个今天把我坑麻了的莫队写法捏 我们开两个数组，cnt[]和num[]，cnt[i]是单纯统计区间里边 i 的出现次数，num[i]统计出现了 i 次的数有多少个。 然后ans就应该是令num[i]不为0的最大的i 考虑到每次更新数的时候，我们其实只会影响一个点的cnt[]和num[]，因此ans只会加1或者减1，因此可以在O(1)的时间内更新捏 那么add和del函数就能这样写了 1234567891011121314151617ll cnt[MAXN], num[MAXN];ll anss = 0;void add(ll x) &#123; ll p = dat[x]; num[cnt[p]]--; cnt[p]++; num[cnt[p]]++; anss = max(anss, cnt[p]);&#125;void del(ll x) &#123; ll p = dat[x]; num[cntt[p]]--; if (anss == cntt[p] &amp;&amp; !num[anss])anss--; --cntt[p]; num[cntt[p]]++;&#125; 本废物因为莫队学的太烂了，以至于没有想到可以用 while(l&lt;=r)del(l++) 手动清零，天天用memset()，T到了天荒地老 小朋友们千万不要学哦","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"https://pophirasawa.top/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"https://pophirasawa.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"hexo博客搭建教程(?","slug":"05杂项/hexo博客搭建","date":"2021-11-07T08:01:02.000Z","updated":"2021-11-08T14:05:53.281Z","comments":true,"path":"2021/11/07/05杂项/hexo博客搭建/","link":"","permalink":"https://pophirasawa.top/2021/11/07/05%E6%9D%82%E9%A1%B9/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"有咩有一种可能,这玩意是写来总结一下当时搭博客是有多么折磨的一件事的捏 介绍一下怎么用hexo搭建博客并部署","text":"有咩有一种可能,这玩意是写来总结一下当时搭博客是有多么折磨的一件事的捏 介绍一下怎么用hexo搭建博客并部署 首先是作为准备工作的首先 下载安装 我们需要 装一个git工具 装一个node.js 装一个hexo git工具和node.js直接去官网上下就行了捏 DownloadGit Node.js 下好了之后我们就可以用Git带的gitbush工具开始整活了 首先到你想作为blog的文件夹里右键打开gitbush，或者直接cd,输入 1npm install -g hexo 之后可以用 1hexo -v 来查版本号，看看是不是真的装好了，喜闻乐见了属于是 Github方面的工作 新建仓库 这个部分有2种 想使用Github pages功能来部署博客的，域名是 GitHub用户名+github.io 想使用cloudflare pages来部署的，域名是 自定+pages.dev 不过其实都行，反正最后可以自定义域名（ 第一种：在github上新建一个仓库，仓库名字是 你的Github用户名.github.io，然后选public 第二种对仓库名没有要求。 SSH key 这个部分是让每次push不用输账号密码了，省去了很多折磨的部分捏 首先在Gitbush里输入 12git config --global user.name &quot;yourname&quot; // 你的Github用户名git config --global user.email &quot;youremail&quot; // 你的Github邮箱 然后创建SSH 1ssh-keygen -t rsa -C &quot;youremail&quot; 然后他就会生成一个.ssh的文件夹，打开这个文件夹 找到id_rsa.pub，把里边的内容复制一哈 最后打开你的Github，找到setting里边有一个SSH keys，直接Add SSH key，把你复制的内容粘进去 用这个看看你有没有成功 1ssh -T git@github.com 他应该会说 1Hi XXX! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 其次是开始部署的其次 这里也有两种选择捏，顺带一提俺是部署到Cloudflare pages上边了 在本地使用hexo 不管怎么说，部署之前我们首先得在本地能跑吧 在你选定的文件夹里 1hexo init myblog //myblog叫啥都行 然后你会发现多了一个叫myblog的文件夹，这个就是你以后写博客，整活的根目录了 cd进这个文件夹 12hexo g //生成页面hexo s //在本地开启服务器预览 这时候你就可以在localhost:4000里看到自己的博客了，他有个预制 一般来说ctrl+c可以关掉服务，不行的话上cmd把占用了4000端口的进程kill掉也行 1hexo s -p 5000 //可以把端口设定到5000，4000端口冲突了也能这样 然后就是激动人心的部署到网站上了捏，可以 部署到Github Pages 部署到Cloudflare Pages 部署到Github Pages 打开你hexo init新建的文件夹，找到_config.yml 在里边找到deploy，改一改 123456deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master // repo里边把YourgithubName替换成你自己的 // branch里边把master换成你那个仓库主分支的名字 然后还要装一个 1npm install hexo-deployer-git --save // 有时候装了新主题报错的话，把这个重新装一下就行了捏 最后就迎来了我们激动人心的时刻 123hexo clean // 清除原来生成在public里的文件hexo g // 生成hexo d // 部署 就可以了 部署到Cloudflare Pages 首先，在本地使用hexo的那部分都要搞， 不用改deploy里边的东西 然后，我们要注册一个Cloudflare的账号，点开网页选项，创建项目 按照提示绑上你的GitHub账号，选择你作为存博客的那个仓库， 然后自己定一个你要的项目名字，他会部署到 名字.pages.dev上边 构建选项这样写就完事儿了 以后你每次就把整个文件夹push到你的Github上，他会自动构建，一个月有500次，完全够用了捏 最后是个性化以及使用方法的最后 我们已经搞的差不多了，现在是不是该写自己的第一篇博客了？ 输入 1hexo n 博客名 你会发现在source/_post文件夹内出现了一篇markdown，就可以在里边写了捏 这时，好奇的你也许会发现他开头有个类似于 123456---title: xxxdate: tag: category: --- 之类的东西，这个是标定一些你文章的属性的东西，具体来说其实还是要看你用的主题是如何规定的，自己查人主题文档去捏。 tag和category可以写多级,不过tag好像没有上下级的层次，category则是从上到下 123category:- a- b 这样就把你文章放在了a大类下的b小分类下 然后是各种个性化 换主题啊，自定义域名啊啥的，我懒得写了，自己上网查得了 找主题上https://hexo.io/themes/就行","categories":[{"name":"杂项","slug":"杂项","permalink":"https://pophirasawa.top/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://pophirasawa.top/tags/hexo/"}]},{"title":"单调队列优化多重背包","slug":"01或许是算法/单调队列优化dp","date":"2021-11-05T03:13:57.000Z","updated":"2021-11-06T08:38:15.508Z","comments":true,"path":"2021/11/05/01或许是算法/单调队列优化dp/","link":"","permalink":"https://pophirasawa.top/2021/11/05/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/","excerpt":"补题补到了个树上背包，然后发现孩子不会。这次就打算把一些该学的背包都学一手？大概。 我们知道，对于多重背包，有一个二进制拆分优化，可以在O(vlog(∑n[i]))O(vlog(\\sum{n[i]}))O(vlog(∑n[i]))级别的复杂度解决问题 然后单调队列优化可以跑到O(nv)O(nv)O(nv)","text":"补题补到了个树上背包，然后发现孩子不会。这次就打算把一些该学的背包都学一手？大概。 我们知道，对于多重背包，有一个二进制拆分优化，可以在O(vlog(∑n[i]))O(vlog(\\sum{n[i]}))O(vlog(∑n[i]))级别的复杂度解决问题 然后单调队列优化可以跑到O(nv)O(nv)O(nv) 思路 首先我们考虑一下朴素的多重背包写法： 对于当前物品i，枚举选的个数n[i]，用于更新dp数组 然后我们能够发现这样一个神必规律： dp[i]用于维护代价为i的最大价值，且当前考虑选的物品代价为v 则dp[i]只能够从dp[j]，当且仅当j mod v == i mod v 且选的个数不超过要求的点转移过来 也就是 当前在选第i个物品时 dp[j+nv]=max(dp[j+(n−1)v+w,dp[j+(n−2)v+2w,....)dp[j+nv]=max(dp[j+(n-1)v+w,dp[j+(n-2)v+2w,....) dp[j+nv]=max(dp[j+(n−1)v+w,dp[j+(n−2)v+2w,....) 改变一下形式 dp[j+nv]=max(dp[j],dp[j+v]−w,dp[j+2v]−2w,...)+nwdp[j+nv]=max(dp[j],dp[j+v]-w,dp[j+2v]-2w,...)+nw dp[j+nv]=max(dp[j],dp[j+v]−w,dp[j+2v]−2w,...)+nw 当然，因为有个数的限制，他选定的是一定区间里边的最大值，这个就给我们跑单调区间留下了伏笔捏 CODE 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include&lt;bitset&gt;#include&lt;map&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll N, V;ll f[20000 + 5];ll g[20000 + 5];ll q[20000 + 5];int main() &#123; cin &gt;&gt; N &gt;&gt; V; for (int i = 0; i &lt; N; i++) &#123; ll v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, f, sizeof(f)); for (int j = 0; j &lt; v; j++) &#123; ll l = 0, r = -1; for (int k = j; k &lt;= V; k += v) &#123; while (r &gt;= l &amp;&amp; (k - q[l]) &gt; s * v)l++;// 判断区间长度是否超过 while (r &gt;= l &amp;&amp; (g[q[r]] - (q[r] - j) / v * w) &lt; (g[k] - (k - j) / v * w))r--; q[++r] = k; f[k] = max(g[k], g[q[l]] + (k - q[l]) / v * w); &#125; &#125; &#125; ll ans = 0; for (int i = 0; i &lt;= V; i++)ans = max(f[i], ans); cout &lt;&lt; ans;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"算法/DP","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pophirasawa.top/tags/DP/"}]},{"title":"Gym103389F 地图压缩","slug":"03久远时光以前的补题记录/2021-11-5","date":"2021-11-04T16:45:04.000Z","updated":"2021-11-05T02:06:31.797Z","comments":true,"path":"2021/11/05/03久远时光以前的补题记录/2021-11-5/","link":"","permalink":"https://pophirasawa.top/2021/11/05/03%E4%B9%85%E8%BF%9C%E6%97%B6%E5%85%89%E4%BB%A5%E5%89%8D%E7%9A%84%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/2021-11-5/","excerpt":"训练的时候一看题目长的一批就根本没看，现在看看发现还是可做的啊。。 题目简述 给定一个n*n的矩阵，q次询问，每次给定一个矩形范围，问一个最小矩阵的面积，可以通过此矩阵循环覆盖给定的范围，多出的部分可以不计 例如:ababa可以通过ab循环构成","text":"训练的时候一看题目长的一批就根本没看，现在看看发现还是可做的啊。。 题目简述 给定一个n*n的矩阵，q次询问，每次给定一个矩形范围，问一个最小矩阵的面积，可以通过此矩阵循环覆盖给定的范围，多出的部分可以不计 例如:ababa可以通过ab循环构成 思路 如果一个子矩阵满足条件，把这玩意纵向扩展后肯定也可以满足条件，那么我们求可以横向循环满足的循环节和纵向的循环节长度，乘一下就行。 用hash把这玩意压成一维，在找循环节就行了。 这个就是找最长公共前后缀长度d，那么n-d就是循环节长度。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include&lt;bitset&gt;#include&lt;map&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const ll maxn = 5e5+ 5;const ll mod = 1e9 + 7;ull p1 = 131;ull p2 = 20111203;char dat[3000][3000];ull h1[3000][3000], h2[3000][3000],pp1[3000],pp2[3000];ll q;ull r[3000], c[3000];int main() &#123; ll n,q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;=n; i++)cin &gt;&gt; dat[i]+1; pp1[0] = pp2[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; pp1[i] = pp1[i - 1] * p1; pp2[i] = pp2[i - 1] * p2; &#125; for (int i = 1; i &lt;=n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; h1[i][j] = h1[i - 1][j] * p1 + dat[i][j] - &#x27;a&#x27;; h2[i][j] = h2[i][j-1] * p1 + dat[i][j] - &#x27;a&#x27;; &#125; &#125; //cin &gt;&gt; q; while (q--) &#123; ll x1, x2, y1, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; for (int i = y1; i &lt;= y2; i++)r[i] = h1[x2][i] - h1[x1 - 1][i] * pp1[x2 - x1 + 1]; for (int i = x1; i &lt;= x2; i++)c[i] = h2[i][y2] - h2[i][y1-1] * pp1[y2 - y1 + 1]; ull s1 = 0, s2 = 0; ll ans1 = -1, ans2 = -1; for (int i = 0; i+y1&lt;y2; i++) &#123; s1 = s1 * p2 + r[i+y1]; s2 = s2 + r[y2 - i]*pp2[i]; if (s1 == s2)ans1 = i; &#125; ans1 = y2 - y1 - ans1; s1 = s2 = 0; for (int i = 0; i + x1 &lt; x2; i++) &#123; s1 = s1 * p2 + c[i + x1]; s2 = s2 + c[x2 - i] * pp2[i]; if (s1 == s2)ans2 = i; &#125; ans2 = x2 - x1 - ans2; cout &lt;&lt; ans2 * ans1 &lt;&lt; &#x27;\\n&#x27;; &#125;&#125; 这里考虑一下如果d==n的时候，其实答案是n而不是n-d，把ans预设为-1可以很巧妙的解决。 结果写的时候天天犯病，对题解抄都nm能给抄歪来，hash也迷惑冲突，只能说base不能乱设了呃呃。","categories":[{"name":"补题","slug":"补题","permalink":"https://pophirasawa.top/categories/%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://pophirasawa.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"瞎掰","slug":"胡言乱语们/0X01","date":"2021-11-02T16:00:00.000Z","updated":"2022-01-03T13:41:28.552Z","comments":true,"path":"2021/11/03/胡言乱语们/0X01/","link":"","permalink":"https://pophirasawa.top/2021/11/03/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/0X01/","excerpt":"","text":"稍微回顾一下我这十几年的无聊人生经历，可以发现差不多没有任何意义。 是不是说的有点过头了（ 其实没有？ 总的来说，是有乐子，但是与故事无缘 从来没有自己真正想做什么 从来没有真正努力做过什么 因此， 付出汗与血，历经千难万难，无论结果为何，在将来回想起时， 如同某个明媚夏日、某场淅沥小雨、某道绚丽彩虹、某天傍晚意外地抬起头所看见的红色、橙色、粉色、玫瑰色、湖蓝色、群青色一般 令人莫名心跳加速的所谓美好回忆， 对我来说好像并不存在。 或许有过？ 然而最后的结局不是成功或者失败，而是被放弃、丢弃、遗忘，以至于不了了之。所谓找到的能够为之奋斗的事物最后不过是随波逐流，或者莫名自信的自我催眠。 无论如何，最后只能看着别人的故事，感受并不存在的回忆。最后再想想，如果我能这样能够如何如何。 都一样了。 想着改变却无所作为，渴望故事却不主动争取，向往美好但是固守蜗居。 那又如何 老子活得还不是好好的，哈哈。 顺便做下实验，传新的md会不会影响旧的评论啊","categories":[{"name":"胡言乱语","slug":"胡言乱语","permalink":"https://pophirasawa.top/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"}],"tags":[{"name":"胡言乱语们","slug":"胡言乱语们","permalink":"https://pophirasawa.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/"}]},{"title":"信息论","slug":"04学习/信息论","date":"2021-10-30T16:00:00.000Z","updated":"2021-11-03T04:35:51.115Z","comments":true,"path":"2021/10/31/04学习/信息论/","link":"","permalink":"https://pophirasawa.top/2021/10/31/04%E5%AD%A6%E4%B9%A0/%E4%BF%A1%E6%81%AF%E8%AE%BA/","excerpt":"呃呃呃 这玩意就是信息论课的内容了 以后更估计也就在这篇里面更了 大概","text":"呃呃呃 这玩意就是信息论课的内容了 以后更估计也就在这篇里面更了 大概 以下内容更新于2021-10-31 信息度量 离散信息度量 首先肯定是经典的各种符号约定,顺遍让我复习一哈LateX语法… 随机事件：xxx 随机变量：XXX x=ai的概率x=a_i的概率x=ai​的概率：Px(ai)P_x(a_i)Px​(ai​) 联合概率：Pxy(ai,bj)P_{xy}(a_i,b_j)Pxy​(ai​,bj​) 自信息 事件集合X中x=aix=a_ix=ai​的自信息 Ix(ai)=−logPx(ai)I_x(a_i)=-logP_x(a_i)Ix​(ai​)=−logPx​(ai​) I(x)=−logp(x)I(x)=-logp(x)I(x)=−logp(x) 底数可变 log2xlog_2xlog2​x：比特 lnxlnxlnx：奈特 log10xlog_{10}xlog10​x：哈特 自信息的含义即 事件发生前的不确定性 事件发生后事件包含的信息量 联合自信息 即一些事件看作一个联合事件后计算自信息，概率为联合概率 IXY(ai,bj)=−logPXY(ai,bj)I_{XY}(a_i,b_j)=-logP_{XY}(a_i,b_j)IXY​(ai​,bj​)=−logPXY​(ai​,bj​) I(xy)=−logp(xy)I(xy)=-logp(xy)I(xy)=−logp(xy) xyxyxy视为一联合事件 条件自信息 即给定一些事件后，发生其他事件的自信息 Ix∣y(ai,bj)=−logPX∣Y(ai,bj)I_{x|y}(a_i,b_j)=-logP_{X|Y}(a_i,b_j)Ix∣y​(ai​,bj​)=−logPX∣Y​(ai​,bj​) I(x∣y)=−logp(x∣y)I(x|y)=-logp(x|y)I(x∣y)=−logp(x∣y) 因此有： I(xy)=I(x)+I(y∣x)=I(y)+I(x∣y)I(xy)=I(x)+I(y|x)=I(y)+I(x|y)I(xy)=I(x)+I(y∣x)=I(y)+I(x∣y) 综上 自信息量表示一个/多个事件发生带给我们信息量的大小 表示了确定一个/多个事件是否发生，所需要的信息量的大小 log2log_2log2​情况下表示了表示出事件信息量所需要的二进制位的个数 互信息 反映了两个事件之间的统计关联程度 通信系统中，意义是输出端接受到某信息y后获得关于输入端某信息x的信息量 Ix;y(ai;bj)=logPX/Y(ai∣bj)PX(ai)I_{x;y}(a_i;b_j)=log\\frac{P_{X/Y}(a_i|b_j)}{P_X(a_i)}Ix;y​(ai​;bj​)=logPX​(ai​)PX/Y​(ai​∣bj​)​ I(x;y)=I(x)−I(x∣y)I(x;y)=I(x)-I(x|y)I(x;y)=I(x)−I(x∣y) //xxx本身的不确定性减去由yyy确定的xxx的不确定性 I(x;y)=I(y;x)I(x;y)=I(y;x)I(x;y)=I(y;x) 信息熵 离散信源X的熵定义位自信息的平均值，记为H(X) H(X)=E[I(x)]H(X)=E[I(x)]H(X)=E[I(x)] 单位：比特/符号 表现一个信源的平均不确定性/平均信息量、H(x)H(x)H(x)大的随机性大、输出后解除信息不确定行需要的信息量。 条件熵 联合集XYXYXY上，条件自信息I(y∣x)I(y|x)I(y∣x)均值 H(Y∣X)=E[I(y∣x)]=∑xp(x)H(Y∣X=x)H(Y|X)=E[I(y|x)]=\\sum_{x}{p(x)H(Y|X=x)}H(Y∣X)=E[I(y∣x)]=∑x​p(x)H(Y∣X=x) 联合熵 联合集XYXYXY上，条件自信息I(xy)I(xy)I(xy)均值 H(XY)=E[U(xy)]=−∑x∑yp(xy)logp(xy)H(XY)=E[U(xy)]=-\\sum_x\\sum_yp(xy)logp(xy)H(XY)=E[U(xy)]=−∑x​∑y​p(xy)logp(xy) 相对熵——信息散度 没懂。 不等式：1−1x≤lnx≤x−11-\\frac{1}{x}\\leq lnx \\leq x-11−x1​≤lnx≤x−1 熵的不增原理——条件熵不大于信息熵 H(Y∣X)≤H(Y)H(Y|X)\\leq H(Y)H(Y∣X)≤H(Y) 信息熵基本性质 对称性 非负性 确定性：集合中任意事件概率为1时，熵为0 扩展性：小概率事件对熵影响很小可以忽略 可加性：H(XY)=H(X)+H(Y∣X)H(XY)=H(X)+H(Y|X)H(XY)=H(X)+H(Y∣X) 熵的链原则：H(X1X2..XN)=H(X1)+H(X2∣X1)+...H(XN∣X1..XN−1)H(X_1X_2..X_N)=H(X_1)+H(X_2|X_1)+...H(X_N|X_1..X_{N-1})H(X1​X2​..XN​)=H(X1​)+H(X2​∣X1​)+...H(XN​∣X1​..XN−1​) 极值性：集合中事件等概率发生时熵达到最大 平均互信息 集合Y与事件x=ai间的互信息集合Y与事件x=a_i间的互信息集合Y与事件x=ai​间的互信息 I(x;Y)=∑xp(x)I(x;Y)I(x;Y)=\\sum_xp(x)I(x;Y)I(x;Y)=∑x​p(x)I(x;Y) =∑x,yp(x)p(y∣x)logp(y∣x)p(y)=\\sum_{x,y}p(x)p(y|x)log\\frac{p(y|x)}{p(y)}=∑x,y​p(x)p(y∣x)logp(y)p(y∣x)​ 因此 集合X、Y间平均互信息集合X、Y间平均互信息集合X、Y间平均互信息 I(X;Y)=∑xp(x)I(x;Y)I(X;Y)=\\sum_xp(x)I(x;Y)I(X;Y)=∑x​p(x)I(x;Y) 含义 知道集合YYY后，平均Y中一个事件消除掉的关于集合XXX中一个事件的不确定性 集合YYY中一个事件平均能提供出的关于集合XXX中一事件的信息量 两个集合关系密切程度 平均互信息与熵 I(X;Y)=H(X)−H(X∣Y)=H(Y)−H(Y∣X)=H(X)+H(Y)−H(XY)I(X;Y)=H(X)-H(X|Y)=H(Y)-H(Y|X)=H(X)+H(Y)-H(XY)I(X;Y)=H(X)−H(X∣Y)=H(Y)−H(Y∣X)=H(X)+H(Y)−H(XY) 性质 非负性 互易性 凸函数性： 为p(x)p(x)p(x)上凸函数","categories":[{"name":"课内","slug":"课内","permalink":"https://pophirasawa.top/categories/%E8%AF%BE%E5%86%85/"}],"tags":[{"name":"信息论","slug":"信息论","permalink":"https://pophirasawa.top/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"}]},{"title":"通信原理","slug":"04学习/通信原理","date":"2021-10-30T16:00:00.000Z","updated":"2021-11-03T04:35:55.156Z","comments":true,"path":"2021/10/31/04学习/通信原理/","link":"","permalink":"https://pophirasawa.top/2021/10/31/04%E5%AD%A6%E4%B9%A0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/","excerpt":"","text":"目前啥都没有","categories":[{"name":"课内","slug":"课内","permalink":"https://pophirasawa.top/categories/%E8%AF%BE%E5%86%85/"}],"tags":[{"name":"通信原理","slug":"通信原理","permalink":"https://pophirasawa.top/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}]},{"title":"EXGCD","slug":"01或许是算法/类&拓展欧几里得","date":"2021-10-29T16:00:00.000Z","updated":"2021-11-01T16:34:16.267Z","comments":true,"path":"2021/10/30/01或许是算法/类&拓展欧几里得/","link":"","permalink":"https://pophirasawa.top/2021/10/30/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E7%B1%BB&%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"EXGCD 用于解形如ax+by=gcd（a，b）方程的通解","text":"EXGCD 用于解形如ax+by=gcd（a，b）方程的通解 12345678910111213void exgcd(int &amp;x,int &amp;y,int a,int b)&#123; if(!b) &#123; x=1; y=0; return; &#125; exgcd(x,y,b,a%b); int t=x; x=y; y=t-a/b*y;&#125; 也可以解出ax+by=c gcd（a，b）|c的解 上方参数还是gcd（a，b） 解出后x2=x*c/gcd（a，b） y2=y*c/gcd（a，b） 通解为： {(x, y) | x = x2 + k * b / gcd(a, b)， y = y2 - k * a / gcd(a, b), k ∈ z} 特别的 gcd（a，b）等于1时 相当于求ax=1（modb） 为a在b下的逆元（不用b是质数） 解出x后用 x=（x%b+b）%b求出在0-b范围内的x即为逆元 类欧几里得 当我们要计算形如 ∑i=0n⌊ai+bc⌋ \\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor i=0∑n​⌊cai+b​⌋ 且a，b&gt;=0,c&gt;0时 可以使用类欧算法。 首先有以下公式 ⌈ab⌉=⌊a+b−1b⌋\\lceil \\frac{a}{b}\\rceil = \\lfloor \\frac{a+b-1}{b}\\rfloor ⌈ba​⌉=⌊ba+b−1​⌋ ⌊ab⌋=⌈a−b+1b⌉\\lfloor\\frac{a}{b}\\rfloor = \\lceil \\frac{a-b+1}{b}\\rceil ⌊ba​⌋=⌈ba−b+1​⌉ 挺容易推的：关于1式，如果 a % b != 0,那么右边就会比左边大1，2式原理相同。 然后开始推（？ 我们令 F(a,b,c,n)=∑i=0n⌊ai+bc⌋F(a,b,c,n)=\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor F(a,b,c,n)=i=0∑n​⌊cai+b​⌋ a≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n(⌊a%c×i+bc⌋+⌊ac⌋i)=∑i=0n⌊a%c×i+bc⌋+⌊ac⌋n×(n+1)2{a}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n(\\lfloor \\frac{a\\%c\\times i+b}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor i)=\\sum_{i=0}^n\\lfloor \\frac{a\\%c\\times i+b}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} a≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​(⌊ca%c×i+b​⌋+⌊ca​⌋i)=i=0∑n​⌊ca%c×i+b​⌋+⌊ca​⌋2n×(n+1)​ b≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n⌊ai+b%cc⌋+⌊bc⌋(n+1){b}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n\\lfloor \\frac{a i+b\\% c}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor(n+1) b≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​⌊cai+b%c​⌋+⌊cb​⌋(n+1) 因此 a≥c∣∣b≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n⌊(a%c)i+b%cc⌋+⌊bc⌋(n+1)+⌊ac⌋n×(n+1)2{a}\\geq{c}||{b}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n\\lfloor \\frac{(a\\%c) i+b\\% c}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor(n+1)+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} a≥c∣∣b≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​⌊c(a%c)i+b%c​⌋+⌊cb​⌋(n+1)+⌊ca​⌋2n×(n+1)​ ⇒F(a,b,c,n)=F(a%c,b%c,c,n)++⌊bc⌋(n+1)+⌊ac⌋n×(n+1)2\\Rightarrow F(a,b,c,n) = F(a\\%c,b\\%c,c,n)++\\lfloor\\frac{b}{c}\\rfloor(n+1)+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} ⇒F(a,b,c,n)=F(a%c,b%c,c,n)++⌊cb​⌋(n+1)+⌊ca​⌋2n×(n+1)​ 之后只要解决a&lt;c&amp;&amp;b&lt;ca \\lt c \\&amp;\\&amp; b\\lt ca&lt;c&amp;&amp;b&lt;c的情况就好了（？ 由 ∑i=0n⌊ai+bc⌋=∑i=0n∑j=1⌊ai+bc⌋1=∑i=0n∑j=1⌊an+bc⌋[j≤⌊ai+bc⌋]\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor =\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor \\frac{ai+b}{c}\\rfloor}1 =\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[{j\\leq \\lfloor \\frac{ai+b}{c}\\rfloor}] i=0∑n​⌊cai+b​⌋=i=0∑n​j=1∑⌊cai+b​⌋​1=i=0∑n​j=1∑⌊can+b​⌋​[j≤⌊cai+b​⌋] 交换求和顺序（ ⇒∑j=1⌊an+bc⌋∑i=0n[j≤⌊ai+bc⌋]\\Rightarrow \\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[{j\\leq \\lfloor \\frac{ai+b}{c}\\rfloor}] ⇒j=1∑⌊can+b​⌋​i=0∑n​[j≤⌊cai+b​⌋] 又有 ⌊ab⌋≥c⇔a≥bc\\lfloor \\frac{a}{b} \\rfloor \\geq c \\Leftrightarrow a\\geq bc ⌊ba​⌋≥c⇔a≥bc ⌈ab⌉≤c⇔a≤bc\\lceil \\frac{a}{b} \\rceil \\leq c \\Leftrightarrow a\\leq bc ⌈ba​⌉≤c⇔a≤bc 因此 =∑j=1⌊an+bc⌋∑i=0n[jc≤ai+b]=∑j=1⌊an+bc⌋∑i=0n[⌈jc−ba⌉≤i]=∑j=1⌊an+bc⌋[n+1−⌈jc−ba⌉]=\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[jc\\leq {ai+b}] =\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[\\lceil \\frac{jc-b}{a} \\rceil \\leq i] =\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[n+1-\\lceil \\frac{jc-b}{a} \\rceil] =j=1∑⌊can+b​⌋​i=0∑n​[jc≤ai+b]=j=1∑⌊can+b​⌋​i=0∑n​[⌈ajc−b​⌉≤i]=j=1∑⌊can+b​⌋​[n+1−⌈ajc−b​⌉] =∑j=1⌊an+bc⌋[n+1−⌊jc−b+a−1a⌋]=\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[n+1-\\lfloor \\frac{jc-b+a-1}{a} \\rfloor] =j=1∑⌊can+b​⌋​[n+1−⌊ajc−b+a−1​⌋] =n⌊an+bc⌋−∑j=1⌊an+bc⌋[⌊jc−b+a−1a⌋−1]=n⌊an+bc⌋−∑j=0⌊an+bc⌋−1[⌊(j+1)c−b−1a⌋]=n\\lfloor \\frac{an+b}{c}\\rfloor-\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[\\lfloor \\frac{jc-b+a-1}{a} \\rfloor-1] =n\\lfloor \\frac{an+b}{c}\\rfloor-\\sum_{j=0}^{\\lfloor \\frac{an+b}{c}\\rfloor-1}[\\lfloor \\frac{(j+1)c-b-1}{a} \\rfloor] =n⌊can+b​⌋−j=1∑⌊can+b​⌋​[⌊ajc−b+a−1​⌋−1]=n⌊can+b​⌋−j=0∑⌊can+b​⌋−1​[⌊a(j+1)c−b−1​⌋] 因此我们有a,b&lt;ca,b\\lt ca,b&lt;c时 F(a,b,c,n)=n⌊an+bc⌋−F(c,−1−b+c,a,⌊an+bc⌋−1)F(a,b,c,n)=n\\lfloor \\frac{an+b}{c}\\rfloor-F(c,-1-b+c,a,\\lfloor \\frac{an+b}{c}\\rfloor-1) F(a,b,c,n)=n⌊can+b​⌋−F(c,−1−b+c,a,⌊can+b​⌋−1) 然后就 可以递归了 终止条件a=0 以下代码 123456ll exgcd(ll a, ll b, ll c, ll n)&#123; if(a==0) return (n+1)*(b/c); if(a&gt;=c||b&gt;=c) return exgcd(a%c, b%c, c, n) + floor(a/c)*n*(n+1)/2 + floor(b/c)*(n+1); ll temp = (a*n+b)/c; return n*temp - exgcd(c, c-b-1, a, temp-1);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Hello?","slug":"胡言乱语们/0X00","date":"2021-10-28T16:00:00.000Z","updated":"2022-01-11T16:52:04.174Z","comments":true,"path":"2021/10/29/胡言乱语们/0X00/","link":"","permalink":"https://pophirasawa.top/2021/10/29/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/0X00/","excerpt":"","text":"这里以后也许会有一些胡言乱语…","categories":[{"name":"胡言乱语","slug":"胡言乱语","permalink":"https://pophirasawa.top/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"}],"tags":[{"name":"胡言乱语们","slug":"胡言乱语们","permalink":"https://pophirasawa.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"补题","slug":"补题","permalink":"https://pophirasawa.top/categories/%E8%A1%A5%E9%A2%98/"},{"name":"组合数学","slug":"组合数学","permalink":"https://pophirasawa.top/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"杂项","slug":"杂项","permalink":"https://pophirasawa.top/categories/%E6%9D%82%E9%A1%B9/"},{"name":"DP","slug":"算法/DP","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/DP/"},{"name":"胡言乱语","slug":"胡言乱语","permalink":"https://pophirasawa.top/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"},{"name":"课内","slug":"课内","permalink":"https://pophirasawa.top/categories/%E8%AF%BE%E5%86%85/"},{"name":"数学","slug":"算法/数学","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"回文","slug":"回文","permalink":"https://pophirasawa.top/tags/%E5%9B%9E%E6%96%87/"},{"name":"字符串","slug":"字符串","permalink":"https://pophirasawa.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数学","slug":"数学","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/tags/SAM/"},{"name":"莫队","slug":"莫队","permalink":"https://pophirasawa.top/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"https://pophirasawa.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"hexo","slug":"hexo","permalink":"https://pophirasawa.top/tags/hexo/"},{"name":"DP","slug":"DP","permalink":"https://pophirasawa.top/tags/DP/"},{"name":"胡言乱语们","slug":"胡言乱语们","permalink":"https://pophirasawa.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/"},{"name":"信息论","slug":"信息论","permalink":"https://pophirasawa.top/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"},{"name":"通信原理","slug":"通信原理","permalink":"https://pophirasawa.top/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"数论","slug":"数论","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E8%AE%BA/"}]}