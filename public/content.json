{"meta":{"title":"PopHirasawa's Blog","subtitle":"循此苦旅，直抵群星。","description":"","author":"PopHirasawa","url":"https://pophirasawa.top","root":"/"},"pages":[{"title":"categories","date":"2021-10-29T10:05:49.000Z","updated":"2021-10-29T11:06:46.569Z","comments":true,"path":"categories/index.html","permalink":"https://pophirasawa.top/categories/index.html","excerpt":"","text":""},{"title":"Pophirasawa","date":"2021-10-29T09:21:07.000Z","updated":"2021-10-31T08:54:23.820Z","comments":true,"path":"about/index.html","permalink":"https://pophirasawa.top/about/index.html","excerpt":"","text":"不知道浪费了多少时间，又下定决心好好学习了？ 在此之前，有没有考虑过再看一遍轻音少女呢。"},{"title":"My Friends' Blogs","date":"2021-11-04T05:52:29.000Z","updated":"2023-10-21T15:53:22.781Z","comments":true,"path":"links/index.html","permalink":"https://pophirasawa.top/links/index.html","excerpt":"","text":"有没有一种可能，以下的都是超人捏 确实 Jnnnnn：POPCHICKEN’s Blog 蘑菇：Mushroom323’s Blog Heye：Heyewuyue1’s Blog F0：Ibukifalling’s Blog 伞哥：Fohunbrella’s Blog Bangg：Banned’s Blog TonyZhao：TonyZhao’s Blog WA_Automaton:WA_Automaton’s Blog 孙老师：香芋派Taro’s Blog 山荷叶: 0x39.me 山阳子瑜: 鱼籽 mhy: mhy 石上: 石上 RuaYiii: Rua宝 Poria: Poria 晓羽: 晓羽 天泽龟: 天泽龟 Jungle’s Blog: Jungle anda: anda 泽村睿:泽村睿"},{"title":"tags","date":"2021-10-29T10:04:25.000Z","updated":"2021-10-29T11:06:16.405Z","comments":true,"path":"tags/index.html","permalink":"https://pophirasawa.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"重参数化与Gumbel-Softmax","slug":"04学习/Gumbel Softmax","date":"2023-10-29T15:06:58.000Z","updated":"2023-10-29T15:09:34.069Z","comments":true,"path":"2023/10/29/04学习/Gumbel Softmax/","link":"","permalink":"https://pophirasawa.top/2023/10/29/04%E5%AD%A6%E4%B9%A0/Gumbel%20Softmax/","excerpt":"研究SAC的时候没搞太懂，花了好几天研究这个问题，记录一下 参考： 漫谈重参数：从正态分布到Gumbel Softmax - 科学空间|Scientific Spaces (kexue.fm) VAE中的重参数化技巧-reparameterization trick - 知乎 (zhihu.com)","text":"研究SAC的时候没搞太懂，花了好几天研究这个问题，记录一下 参考： 漫谈重参数：从正态分布到Gumbel Softmax - 科学空间|Scientific Spaces (kexue.fm) VAE中的重参数化技巧-reparameterization trick - 知乎 (zhihu.com) 引入 考虑形如下形式的损失函数： Ep(z)[fθ(z)]\\mathbb{E} _{p(z)}[f_\\theta (z)] Ep(z)​[fθ​(z)] 在连续问题或z的取值空间很大的离散问题中，我们很难或者不可能遍历所有的z，因此需要采样(Monte Carlo)。 若z的分布与我们需要求梯度的参数$ \\theta $无关，则： \\nabla _\\theta \\mathbb{E} _{p(z)}[f_\\theta (z)] &=& \\nabla _\\theta[\\int _zp(z)f_\\theta(z)dz]\\\\ &=& \\int_zp(z)[\\nabla_\\theta f_\\theta(z)]dz\\\\ &=&\\mathbb{E}_{p(z)}[\\nabla_\\theta f_\\theta(z)] 然而，若问题变为： Epθ(z)[fθ(z)]\\mathbb E_{p_\\theta (z)}[f_\\theta(z)] Epθ​(z)​[fθ​(z)] 计算梯度： \\nabla _\\theta \\mathbb{E} _{p_\\theta(z)}[f_\\theta (z)]&=&\\nabla _\\theta[\\int _zp_\\theta(z)f_\\theta(z)dz]\\\\&=&\\int_z\\nabla_\\theta[p_\\theta(z)f_\\theta(z)]dz\\\\&=&\\int_zf_\\theta(z)\\nabla_\\theta p_\\theta(z)dz+\\int_zp_\\theta(z)\\nabla_\\theta f_\\theta (z) dz 由于我们需要计算分布p的梯度，第一项无法变成期望的形式，因此也无法进行采样。 为了解决这个问题，可以使用重参数化技巧与Gumbel-Softmax Reparameterization 原理 考虑连续情况： Lθ=∫zpθ(z)f(z)dzL_\\theta=\\int _zp_\\theta(z)f(z)dz Lθ​=∫z​pθ​(z)f(z)dz 我们需要在进行采样的同时保留$ \\theta $的梯度，为此，我们考虑先从无参分布q中进行采样，然后通过某种变换生成z： ϵ∼q(ϵ)z=gθ(ϵ)\\epsilon \\sim q(\\epsilon)\\\\ z=g_\\theta(\\epsilon) ϵ∼q(ϵ)z=gθ​(ϵ) 此时式子变为： Lθ=Eϵ∼q(ϵ)[f(gθ(ϵ))]L_\\theta=\\mathbb E_{\\epsilon\\sim q(\\epsilon)}[f(g_\\theta(\\epsilon))] Lθ​=Eϵ∼q(ϵ)​[f(gθ​(ϵ))] 此时我们把随机采样和梯度传播解耦了，可以直接反向传播loss 实现 以SAC为例，原本需要从$ \\mathcal{N} (\\mu_\\theta, \\sigma^2_\\theta) $中进行抽样。我们进行重参数化： ϵ∼N(0,1)z=ϵ×σθ+μθ⇒Lθ=Eϵ∼N(0,1)[f(ϵ×σθ+μθ)]\\epsilon\\sim\\mathcal N(0,1)\\\\ z=\\epsilon\\times\\sigma_\\theta+\\mu_\\theta\\\\ \\Rightarrow L_\\theta=\\mathbb E_{\\epsilon\\sim\\mathcal N(0,1)}[f(\\epsilon\\times\\sigma_\\theta+\\mu_\\theta)] ϵ∼N(0,1)z=ϵ×σθ​+μθ​⇒Lθ​=Eϵ∼N(0,1)​[f(ϵ×σθ​+μθ​)] 然后就可以直接进行反向传播更新网络参数 Gumbel-Softmax 原理 现在我们考虑离散情况： Lθ=∑ypθ(y)f(y)L_\\theta=\\sum_yp_\\theta(y)f(y) Lθ​=y∑​pθ​(y)f(y) 显然我们是可以通过这个求和操作直接计算出Loss的， 然而若取值空间非常巨大，我们依旧需要通过采样来估算这个期望。 和上文一样，我们考虑如何分离随机采样： 引入Gumbel-Max： arg⁡max⁡i(log⁡pi−log⁡(−log⁡ϵi))i=1k, ϵi∼U[0,1]\\mathop{\\arg\\max}_i(\\log p_i-\\log(-\\log\\epsilon_i))_{i=1}^k,\\ \\epsilon_i\\sim U[0,1] argmaxi​(logpi​−log(−logϵi​))i=1k​, ϵi​∼U[0,1] 现在已经通过这个一样重参数过程将随机性转移到了均匀分布上，但是由于我们使用了不可导的argmax，还是会丢失梯度信息。 因此，我们引入其光光滑似版本，Gumbel-Softmax： softmaxi((log⁡pi−log⁡(−log⁡ϵi)/τ)i=1k, ϵi∼U[0,1]\\mathop{softmax}_i((\\log p_i-\\log(-\\log\\epsilon_i)/\\tau)_{i=1}^k,\\ \\epsilon_i\\sim U[0,1] softmaxi​((logpi​−log(−logϵi​)/τ)i=1k​, ϵi​∼U[0,1] tau为退火参数，越小则输出越接近One-Hot输出，然而此时会导致梯度消失。因此训练时可以从1开始，慢慢衰减。 证明 要证明Gumbel-Max抽样和原始分布一样，需要证明输出i的概率为pi，此处证明输出1的概率为p1，即： log⁡p1−log⁡(−log⁡ϵ1)&gt;log⁡pi−log⁡(−log⁡ϵi) ,∀i≠1\\log p_1 -\\log(-\\log \\epsilon_1)&gt;\\log p_i-\\log (-\\log \\epsilon_i)\\ ,\\forall i\\neq1 logp1​−log(−logϵ1​)&gt;logpi​−log(−logϵi​) ,∀i​=1 化简得： ϵi&lt;ϵ1pi/p1≤1\\epsilon_i&lt;\\epsilon_1^{p_i/p_1}\\leq1 ϵi​&lt;ϵ1pi​/p1​​≤1 成立概率为： ϵ1(p2+p3+⋯+pk)/p1=ϵ(1/p1)−1∫01ϵ1(1/p1)−1dϵ1=p1\\epsilon _1^{(p_2+p_3+\\cdots+p_k)/p_1}=\\epsilon^{(1/p_1)-1} \\\\ \\int_0^1\\epsilon_1^{(1/p_1)-1}d\\epsilon_1=p_1 ϵ1(p2​+p3​+⋯+pk​)/p1​​=ϵ(1/p1​)−1∫01​ϵ1(1/p1​)−1​dϵ1​=p1​ 证毕。 实现 pytorch自带Gumbel-Softmax函数，看看代码 123456789101112131415gumbels = ( -torch.empty_like(logits, memory_format=torch.legacy_contiguous_format).exponential_().log() ) # ~Gumbel(0,1) gumbels = (logits + gumbels) / tau # ~Gumbel(logits,tau) y_soft = gumbels.softmax(dim) if hard: # Straight through. index = y_soft.max(dim, keepdim=True)[1] y_hard = torch.zeros_like(logits, memory_format=torch.legacy_contiguous_format).scatter_(dim, index, 1.0) ret = y_hard - y_soft.detach() + y_soft else: # Reparametrization trick. ret = y_soft return ret 我们看到，pytorch除了输出类似One-Hot版本，还支持一个hard模式，这步ret = y_hard - y_soft.detach() + y_soft通过分离计算图的方式让前向传播和反向传播不同，反向传播时仍然计算的是y_soft的梯度。","categories":[{"name":"DRL","slug":"DRL","permalink":"https://pophirasawa.top/categories/DRL/"}],"tags":[{"name":"RL","slug":"RL","permalink":"https://pophirasawa.top/tags/RL/"}]},{"title":"CQL-保守Q学习","slug":"04学习/cql","date":"2023-07-25T00:44:45.000Z","updated":"2023-10-21T15:51:27.269Z","comments":true,"path":"2023/07/25/04学习/cql/","link":"","permalink":"https://pophirasawa.top/2023/07/25/04%E5%AD%A6%E4%B9%A0/cql/","excerpt":"记录一下读论文的情况喵 引入 [参数] (S,A,T,r,γ)(\\mathcal{S,A},T,r,\\gamma)(S,A,T,r,γ) 动作、状态空间，T(s′∣s,a)T(\\mathbf{s&#x27;|s,a})T(s′∣s,a)转移，r(s,a)r(\\mathbf{s,a})r(s,a)回报，πβ(a∣s)\\pi_\\beta(\\mathbf{a|s})πβ​(a∣s)数据集行为策略，D\\mathcal{D}D数据集，dπβ(s)d^{\\pi_\\beta}(\\mathbf{s})dπβ​(s)折扣边缘状态分布 D\\mathcal{D}D从dπβ(s)πβ(a∣s)d^{\\pi_\\beta}(\\mathbf{s})\\pi_\\beta(\\mathbf{a|s})dπβ​(s)πβ​(a∣s)中抽样 一个基本的迭代方式如下 Q^k+1←arg⁡min⁡QEs,a,s′∼D[(r(s,a)+γEa′∼π^k(a′∣s′)[Q^k(s′,a′)]−Q(s,a)))2]\\hat{Q}^{k+1} \\leftarrow \\arg \\min _{Q} \\mathbb{E}_{\\mathbf{s}, \\mathbf{a},\\mathbf{s&#x27;} \\sim \\mathcal{D}}\\left[\\left(r(\\mathbf{s}, \\mathbf{a})+\\gamma{\\mathbb{E}}_{\\mathbf{a}&#x27;\\sim\\hat\\pi^k(\\mathbf{a&#x27;|s&#x27;})} [\\hat{Q}^{k}(\\mathbf{s&#x27;}, \\mathbf{a&#x27;})]-Q(\\mathbf{s,a}))\\right)^2 \\right]\\\\ Q^​k+1←argQmin​Es,a,s′∼D​[(r(s,a)+γEa′∼π^k(a′∣s′)​[Q^​k(s′,a′)]−Q(s,a)))2] π^k+1←arg⁡max⁡πEs∼D,a∼πk((a∣s))[Q^k+1(s,a)]\\hat \\pi^{k+1}\\leftarrow \\arg \\max _{\\pi} \\mathbb{E}_{\\mathbf{s}\\sim \\mathcal{D},\\mathbf{a}\\sim\\pi^k(\\mathbf(a|s))}[\\hat Q^{k+1}(\\mathbf{s,a})] π^k+1←argπmax​Es∼D,a∼πk((a∣s))​[Q^​k+1(s,a)] [问题] 对状态-动作对采样不充分导致sample error","text":"记录一下读论文的情况喵 引入 [参数] (S,A,T,r,γ)(\\mathcal{S,A},T,r,\\gamma)(S,A,T,r,γ) 动作、状态空间，T(s′∣s,a)T(\\mathbf{s&#x27;|s,a})T(s′∣s,a)转移，r(s,a)r(\\mathbf{s,a})r(s,a)回报，πβ(a∣s)\\pi_\\beta(\\mathbf{a|s})πβ​(a∣s)数据集行为策略，D\\mathcal{D}D数据集，dπβ(s)d^{\\pi_\\beta}(\\mathbf{s})dπβ​(s)折扣边缘状态分布 D\\mathcal{D}D从dπβ(s)πβ(a∣s)d^{\\pi_\\beta}(\\mathbf{s})\\pi_\\beta(\\mathbf{a|s})dπβ​(s)πβ​(a∣s)中抽样 一个基本的迭代方式如下 Q^k+1←arg⁡min⁡QEs,a,s′∼D[(r(s,a)+γEa′∼π^k(a′∣s′)[Q^k(s′,a′)]−Q(s,a)))2]\\hat{Q}^{k+1} \\leftarrow \\arg \\min _{Q} \\mathbb{E}_{\\mathbf{s}, \\mathbf{a},\\mathbf{s&#x27;} \\sim \\mathcal{D}}\\left[\\left(r(\\mathbf{s}, \\mathbf{a})+\\gamma{\\mathbb{E}}_{\\mathbf{a}&#x27;\\sim\\hat\\pi^k(\\mathbf{a&#x27;|s&#x27;})} [\\hat{Q}^{k}(\\mathbf{s&#x27;}, \\mathbf{a&#x27;})]-Q(\\mathbf{s,a}))\\right)^2 \\right]\\\\ Q^​k+1←argQmin​Es,a,s′∼D​[(r(s,a)+γEa′∼π^k(a′∣s′)​[Q^​k(s′,a′)]−Q(s,a)))2] π^k+1←arg⁡max⁡πEs∼D,a∼πk((a∣s))[Q^k+1(s,a)]\\hat \\pi^{k+1}\\leftarrow \\arg \\max _{\\pi} \\mathbb{E}_{\\mathbf{s}\\sim \\mathcal{D},\\mathbf{a}\\sim\\pi^k(\\mathbf(a|s))}[\\hat Q^{k+1}(\\mathbf{s,a})] π^k+1←argπmax​Es∼D,a∼πk((a∣s))​[Q^​k+1(s,a)] [问题] 对状态-动作对采样不充分导致sample error Bellman算子 我们知道，状态空间与动作空间均为集合，假设状态空间S\\mathcal{S}S为{s1,s2,⋯ ,sn,⋯ }\\{s_1,s_2,\\cdots,s_n,\\cdots\\}{s1​,s2​,⋯,sn​,⋯},动作空间A\\mathcal{A}A为{a1,a2,⋯ ,am,⋯ }\\{a_1,a_2,\\cdots,a_m,\\cdots \\}{a1​,a2​,⋯,am​,⋯}，同时二者可以表示为一系列向量 [定义] 值函数vπ:S→R\\mathbf v_\\pi:\\mathcal S \\rightarrow \\mathbb Rvπ​:S→R，策略π\\piπ下，从状态s开始到结束的回报期望 最优值函数v∗:S→R\\mathbf v_*:\\mathcal S \\rightarrow \\mathbb Rv∗​:S→R，v∗(s)=max⁡πvπ(s)\\mathbf v_*(s)=\\max_\\pi\\mathbf v_\\pi(s)v∗​(s)=maxπ​vπ​(s) [定义] Rsa\\mathcal R^a_sRsa​：状态s做动作a得到的奖励的期望，Ps,s′a\\mathcal P^a_{s,s&#x27;}Ps,s′a​状态转移概率 Rπ(s)=∑a∈Aπ(a∣s)⋅Rsa\\mathbf R_\\pi(s)=\\sum_{a\\in\\mathcal A}\\pi(a|s)\\cdot\\mathcal R^a_sRπ​(s)=∑a∈A​π(a∣s)⋅Rsa​ Pπ(s,s′)=∑a∈Aπ(a∣s)⋅Ps,s′a\\mathbf P_\\pi(s,s&#x27;)=\\sum_{a\\in\\mathcal A}\\pi(a|s)\\cdot\\mathcal P ^a_{s,s&#x27;}Pπ​(s,s′)=∑a∈A​π(a∣s)⋅Ps,s′a​ 同样可以用向量和矩阵考虑 [Bellman Policy Operator] Bπ,\\mathbf B_\\pi,Bπ​, Bπ=Rπ+γPπ⋅v\\mathbf B_\\pi=\\mathbf R_\\pi + \\gamma\\mathbf P_\\pi\\cdot\\mathbf vBπ​=Rπ​+γPπ​⋅v 为线性算子，存在不动点vπ,s.t.Bπvπ=vπ\\mathbf{v_\\pi},s.t.\\mathbf{B_\\pi v_\\pi=v_\\pi}vπ​,s.t.Bπ​vπ​=vπ​ [Bellman Optimality Operator] B∗,\\mathbf B_*,B∗​, B∗v(s)=max⁡a{Rsa+γ∑s′∈SPs,s′a⋅v(s′)}\\mathbf {B_*v}(s)=\\max _a\\{\\mathcal R^a_s+\\gamma\\sum_{s&#x27;\\in\\mathcal S}\\mathcal P^a_{s,s&#x27;}\\cdot\\mathbf v(s&#x27;)\\}B∗​v(s)=maxa​{Rsa​+γ∑s′∈S​Ps,s′a​⋅v(s′)} 同样存在不动点 [贪心策略算子] G,\\mathbf G,G, G(v(s))=arg⁡max⁡a{Rsa+γ∑s′∈SPs,s′a⋅v(s′)}\\mathbf {G}(\\mathbf v(s))=\\arg\\max _a\\{\\mathcal R^a_s+\\gamma\\sum_{s&#x27;\\in\\mathcal S}\\mathcal P^a_{s,s&#x27;}\\cdot\\mathbf v(s&#x27;)\\}G(v(s))=argmaxa​{Rsa​+γ∑s′∈S​Ps,s′a​⋅v(s′)} [性质] Bπ，B∗\\mathbf B_\\pi，\\mathbf B_*Bπ​，B∗​均具有唯一不动点(巴拿赫不动点定理)，且最终收敛至不动点 [值迭代] lim⁡n→∞BπNv=vπ\\lim_{n\\rightarrow\\infty}\\mathbf{B^N_\\pi} \\mathbf{v=v_\\pi}limn→∞​BπN​v=vπ​ [策略迭代] 迭代过程为πk+1=G(vπk)\\pi_{k+1}=\\mathbf G(\\mathbf v_{\\pi_k})πk+1​=G(vπk​​) 原理：由$\\mathbf{B_*v_{\\pi_k}}=\\mathbf B_{\\mathbf G(\\pi_k)}\\mathbf v_{\\pi_k}=\\mathbf B_{\\pi_{k+1}}\\mathbf v_{\\pi_k} ，有，有，有\\mathbf{B_*v_{\\pi_k}}\\ge \\mathbf{B_{\\pi_k}v_{\\pi_k}}= \\mathbf{v_{\\pi_k}}$ 所以Bπk+1Nvπk=vπk+1≥Bπkvπk=vπk\\mathbf{B^N_{\\pi_{k+1}}v_{\\pi_k}}=\\mathbf v_{\\pi_{k+1}}\\ge \\mathbf{B_{\\pi_k}v_{\\pi_k}}= \\mathbf{v_{\\pi_k}}Bπk+1​N​vπk​​=vπk+1​​≥Bπk​​vπk​​=vπk​​，说明这是一个不断优化的过程 由于B∗\\mathbf B_*B∗​有唯一不动点v∗,s.t.B∗v∗=v∗\\mathbf v_*,s.t.\\mathbf {B_*v_*=v_*}v∗​,s.t.B∗​v∗​=v∗​，且单增 因此lim⁡n→∞B∗Nv=v∗\\lim_{n\\rightarrow\\infty}\\mathbf{B^N_*} \\mathbf{v=v_*}limn→∞​B∗N​v=v∗​，可以考虑直接迭代 保守Q学习-CQL Policy Evaluation 为了防止高估价值，在原MSE式子的基础上让他最小化Q值来学习保守的下限的Q函数，相当于添加一个惩罚项来让Q函数没那么大 具体来说，我们考虑一个特定的动作-状态分布μ(s,a)\\mu(\\mathbf{s,a})μ(s,a)，最小化该分布下的Q函数。由于普通Q函数的训练过程中不会查询未出现过状态下的Q函数值，只查询未出现过动作下的值，令μ\\muμ匹配数据集，有 μ(s,a)=dπβ(s)μ(a∣s)\\mu{(\\mathbf{s,a})}=d^{\\pi_\\beta}(\\mathbf{s})\\mu(\\mathbf{a|s}) μ(s,a)=dπβ​(s)μ(a∣s) 考虑权衡因子α\\alphaα,我们得到policy evaluation Q^k+1←arg⁡min⁡QαEs∼D,a∼μ(a∣s)[Q(s,a)]+12Es,a∼D[(Q(s,a)−B^πQ^k(s,a))2]\\hat{Q}^{k+1} \\leftarrow \\arg \\min _{Q} \\alpha \\mathbb{E}_{\\mathbf{s} \\sim \\mathcal{D}, \\mathbf{a} \\sim \\mu(\\mathbf{a} \\mid \\mathbf{s})}[Q(\\mathbf{s}, \\mathbf{a})]+\\frac{1}{2} \\mathbb{E}_{\\mathbf{s}, \\mathbf{a} \\sim \\mathcal{D}}\\left[\\left(Q(\\mathbf{s}, \\mathbf{a})-\\hat{\\mathcal{B}}^{\\pi} \\hat{Q}^{k}(\\mathbf{s}, \\mathbf{a})\\right)^{2}\\right] Q^​k+1←argQmin​αEs∼D,a∼μ(a∣s)​[Q(s,a)]+21​Es,a∼D​[(Q(s,a)−B^πQ^​k(s,a))2] 通过再添加一项，我们能大大收紧这个下界： Q^k+1←arg⁡min⁡Qα⋅(Es∼D,a∼μ(a∣s)[Q(s,a)]−Es∼D,a∼π^β(a∣s)[Q(s,a)])+12Es,a∼D[(Q(s,a)−B^πQ^k(s,a))2]\\hat{Q}^{k+1} \\leftarrow \\arg \\min _{Q} \\alpha \\cdot(\\mathbb{E}_{\\mathbf{s} \\sim \\mathcal{D}, \\mathbf{a} \\sim \\mu(\\mathbf{a} \\mid \\mathbf{s})}[Q(\\mathbf{s}, \\mathbf{a})]-{\\color{red}\\mathbb{E}_{\\mathbf{s} \\sim \\mathcal{D}, \\mathbf{a} \\sim \\hat{\\pi}_\\beta(\\mathbf{a} \\mid \\mathbf{s})}[Q(\\mathbf{s}, \\mathbf{a})]})\\\\+\\frac{1}{2} \\mathbb{E}_{\\mathbf{s}, \\mathbf{a} \\sim \\mathcal{D}}\\left[\\left(Q(\\mathbf{s}, \\mathbf{a})-\\hat{\\mathcal{B}}^{\\pi} \\hat{Q}^{k}(\\mathbf{s}, \\mathbf{a})\\right)^{2}\\right] \\\\ Q^​k+1←argQmin​α⋅(Es∼D,a∼μ(a∣s)​[Q(s,a)]−Es∼D,a∼π^β​(a∣s)​[Q(s,a)])+21​Es,a∼D​[(Q(s,a)−B^πQ^​k(s,a))2] 原理看不懂，貌似是考虑了采样的集中性质 此时在μ=π\\mu=\\piμ=π时，该式给出了策略π\\piπ下的预期值的限制 [结论] 式子给出了一个真实Q函数的下限，而且数据越多，保证下界的α\\alphaα值减小 CQL 考虑优化策略，由于式2要求μ=π\\mu=\\piμ=π，我们可以考虑每次迭代π^k\\hat\\pi^kπ^k后迭代式2得到Q值，然而这样计算开销过大 因此考虑使用μ\\muμ近似那个能最大化当前Q函数迭代的策略 因此对式2修正为 min⁡Qmax⁡μα⋅(Es∼D,a∼μ(a∣s)[Q(s,a)]−Es∼D,a∼π^β(a∣s)[Q(s,a)])+12Es,a∼D[(Q(s,a)−B^πQ^k(s,a))2]+R(μ)\\min _{Q} \\max_{\\mu}\\alpha \\cdot(\\mathbb{E}_{\\mathbf{s} \\sim \\mathcal{D}, \\mathbf{a} \\sim \\mu(\\mathbf{a} \\mid \\mathbf{s})}[Q(\\mathbf{s}, \\mathbf{a})]-{\\color{black}\\mathbb{E}_{\\mathbf{s} \\sim \\mathcal{D}, \\mathbf{a} \\sim\\hat{\\pi}_\\beta(\\mathbf{a} \\mid \\mathbf{s})}[Q(\\mathbf{s}, \\mathbf{a} ) ] } ) \\\\+\\frac{1}{2} \\mathbb{E}_{\\mathbf{s}, \\mathbf{a} \\sim \\mathcal{D}}\\left[\\left(Q(\\mathbf{s}, \\mathbf{a})-\\hat{\\mathcal{B} }^{\\pi} \\hat{Q}^{k}(\\mathbf{s}, \\mathbf{a})\\right)^{2}\\right] +\\mathcal{R}(\\mu) Qmin​μmax​α⋅(Es∼D,a∼μ(a∣s)​[Q(s,a)]−Es∼D,a∼π^β​(a∣s)​[Q(s,a)])+21​Es,a∼D​[(Q(s,a)−B^πQ^​k(s,a))2]+R(μ) 其中R(μ)\\mathcal{R}(\\mu)R(μ)为正则项，防止过拟合 考虑使用KL散度作为正则项，计先验分布ρ(a∣s)\\rho(\\mathbf{a|s})ρ(a∣s)，则有R(μ)=−DKL(μ,ρ)\\mathcal R(\\mu)=-D_{KL}(\\mu,\\rho)R(μ)=−DKL​(μ,ρ) 两个想法是把这个先验分布设置成均匀分布或者π^k−1\\hat\\pi^{k-1}π^k−1的分布 [正则化] 由于先要找到μ\\muμ令式子最大，R(μ)\\mathcal{R}(\\mu)R(μ)能减少分布的方差，防止过拟合","categories":[{"name":"DRL","slug":"DRL","permalink":"https://pophirasawa.top/categories/DRL/"}],"tags":[{"name":"RL","slug":"RL","permalink":"https://pophirasawa.top/tags/RL/"}]},{"title":"价值学习","slug":"04学习/价值学习","date":"2023-03-22T12:03:12.000Z","updated":"2023-10-21T15:51:35.463Z","comments":true,"path":"2023/03/22/04学习/价值学习/","link":"","permalink":"https://pophirasawa.top/2023/03/22/04%E5%AD%A6%E4%B9%A0/%E4%BB%B7%E5%80%BC%E5%AD%A6%E4%B9%A0/","excerpt":"还是得把学的东西记下来，呃不然过段时间就忘了 价值学习 DQN 动作价值函数Qπ是按照策略π下，环境s做出a动作后的收益期望。 最优动作函数Q⋆是所有策略中取最优的收益期望。这个东西显然可以给动作打分。 折扣回报率γ是为了让策略更早获得更大的回报设置的参数，每次都让回报乘一个γ的t次方","text":"还是得把学的东西记下来，呃不然过段时间就忘了 价值学习 DQN 动作价值函数Qπ是按照策略π下，环境s做出a动作后的收益期望。 最优动作函数Q⋆是所有策略中取最优的收益期望。这个东西显然可以给动作打分。 折扣回报率γ是为了让策略更早获得更大的回报设置的参数，每次都让回报乘一个γ的t次方 如何学习这个Q⋆呢，我们使用一个深度网络来模拟，记作Q(s，a；w)，w就是神经网络中的参数，我们随机初始化w，然后学习w，最后让Q(s，a；w)尽量接近真正的Q⋆(s，a)即可。 DQN输出的是离散的价值空间，也就是每个a上边的Q值。 我们可以使用TD算法来学习w，我们先计算当前情况Q(s，a；w)预测的价值，随后执行动作a，环境到达s1，获得回报r1，这时我们比较Q(s，a；w)和r1+γ*Q(s1，a1；w）即可，a1为s1状态下让预测值最大的行动。 这样就有了Loss，我们可以梯度下降更新w了。即 w←w−α⋅δ⋅∇Qw ← w − α · δ · ∇Q w←w−α⋅δ⋅∇Q Loss函数一般是1/2δ21/2δ^21/2δ2 这玩意是off-policy的，可以乱搞策略，但是一般的是 ϵ-greedy，(1-ϵ)概率用让Q(s，a；w)最大的a，ϵ概率随机挑一个a跑。而且可以应用经验回放，只需要记录以前的(s,a,r,s1)就可以拿这个数据来多次训练网络。 Q-Learning 和 SARSA 一个学Q⋆一个学Qπ 普通的Q学习已经不常用，SARSA通过TD训练Qπ，随后通过某种跟该算法无关的东西更新策略π，SARSA是on-policy的不能利用经验回放，如果状态空间是无限的我们也可以在SARSA上套个神经网络，跟DQN差不多了。 杂项 多步TD TD时多进行几次动作然后进行TD即可。 蒙特卡洛 一次进行完游戏，计算总回报ut，然后鼓励价值网络接近ut。好处是无偏性，坏处是方差大收敛很慢。 自举 TD算法属于自举，好处是方差小，收敛快，坏处是估算有偏。 价值学习技术 优先经验回放 通常在经验回放数组中有足够的四元组时才开始使用经验回放更新DQN 经验回放的优点是可以打破序列的相关性，因为随机抽到的四元组都是独立的 经验回放可以用更少的样本获得同样的表现 优先经验回放是这种方法的优化，即给某些回放数据更高的权重，令其更容易被抽中。 如何判断权重呢，我们可以想象，如果某个数据下的DQN的预测和真正的Q⋆距离较远，是否可以认为该数据应该更收到关注呢。 常用的分配权重方法有两种： pj∝∣δj∣+ϵp_j\\propto|\\delta_j|+\\epsilon pj​∝∣δj​∣+ϵ pj∝1rank(j)p_j\\propto\\frac{1}{rank(j)} pj​∝rank(j)1​ 其中ϵ\\epsilonϵ是一个很小的数，防止有些东西抽不到，rank(j)是排序后的序号 然而权重不同时，我们也应该设置梯度下降不同的学习率来抵消非均匀抽样造成的误差 αj=α(b⋅pj)β\\alpha_j=\\frac{\\alpha}{(b\\cdot p_j)^\\beta} αj​=(b⋅pj​)βα​ 其中β\\betaβ是超参数，b是经验回放样本总数。 Q学习高估问题 目标网络与双Q学习 Q学习会高估真实价值。原因是 自举导致偏差传播 最大化问题导致高估(噪声均值为0，然而取最大值会导致高估) 高估是非均匀的，因此会造成偏差。 我们可以使用目标网络降低自举的危害，即使用一个结构相同但是参数不同的目标网络Q(s,a;w1)来估算TD目标，梯度下降更新原网络,然后用一个加权平均更新目标网络。 要降低最大化偏差，我们可以使用一种Double Q-learning，该方法在目标网络上更进一步。流程如下 设目标网络为ωnow−\\omega_{now}^-ωnow−​ 计算DQN正向传播q^=Q(sj,aj;ωnow)\\hat{q}=Q(s_j,a_j;\\omega_{now})q^​=Q(sj​,aj​;ωnow​) 找到a令a∗=argmaxQ(sj+1,a;ωnow)a^*=argmaxQ(s_{j+1},a;\\omega_{now})a∗=argmaxQ(sj+1​,a;ωnow​) 计算q^j+1=Q(sj,a∗;ωnow−)\\hat{q}_{j+1}=Q(s_j,a^*;\\omega_{now}^-)q^​j+1​=Q(sj​,a∗;ωnow−​) 计算TD误差 梯度下降更新DQN网络 加权平均更新目标网络 对决网络 最优状态价值函数是对Q⋆的所有动作和回报取期望V⋆(s) 定义最优优势函数D⋆(s,a)=Q⋆(s,a)-V⋆(s) 又有以下定理D⋆(s,a)=Q⋆(s,a)-V⋆(s)-maxD⋆(s,a1)，其中a1为令D⋆(s,a)最大的a 这意味着我们如果能把D⋆和V⋆搞出来就可以获得输出的Q 而且这个东西的训练和DQN完全相同，所用优化方法也能应用在这上面。 噪声网络 这玩意可以应用与几乎所有的深度强化学习方法中，而且能显著提高DQN的表现 基本原理为把ω改为μ(均值)+σ(标准差)∘ϵ(随机噪声)\\omega改为\\mu(均值)+\\sigma(标准差)\\circ\\epsilon(随机噪声)ω改为μ(均值)+σ(标准差)∘ϵ(随机噪声)，噪声符合N(0,1)分布，该符号表示逐项乘积，即ωi=μi+σi∗ϵi\\omega_i=\\mu_i+\\sigma_i*\\epsilon_iωi​=μi​+σi​∗ϵi​，这个意思是就是神经网络的参数从一个给定均值和标准差的正态分布中抽取。 训练时加入噪声可以鼓励网络进行更多的探索，而训练完成后决策可以把方差设为0，这时网络就变为了标准的DQN网络。 最终训练时可以把本部分提到的所有技巧全部用上。","categories":[{"name":"DRL","slug":"DRL","permalink":"https://pophirasawa.top/categories/DRL/"}],"tags":[{"name":"RL","slug":"RL","permalink":"https://pophirasawa.top/tags/RL/"}]},{"title":"对顶栈","slug":"01或许是算法/对顶栈","date":"2022-08-05T16:31:00.000Z","updated":"2022-08-05T16:31:44.699Z","comments":true,"path":"2022/08/06/01或许是算法/对顶栈/","link":"","permalink":"https://pophirasawa.top/2022/08/06/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E5%AF%B9%E9%A1%B6%E6%A0%88/","excerpt":"","text":"对顶栈 用于维护一种光标线性移动，而且插入和删除都是发生在光标左右的数据结构 顾名思义，对顶栈就是两个栈，一个维护光标左边的内容，一个维护光标右边的内容，光标的移动就是把一边的弹出来塞到另外一边就行，添加和删除操作也很简单了，就是对栈进行相应操作就行。 Problem - 4699 (hdu.edu.cn)","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"c++ primer 读书笔记(1)","slug":"04学习/cpp(1)","date":"2022-06-15T19:46:12.000Z","updated":"2022-06-16T11:57:39.855Z","comments":true,"path":"2022/06/16/04学习/cpp(1)/","link":"","permalink":"https://pophirasawa.top/2022/06/16/04%E5%AD%A6%E4%B9%A0/cpp(1)/","excerpt":"包含以下内容： 异常 IO流 泛型","text":"包含以下内容： 异常 IO流 泛型 异常处理 throw try catch throw可以抛出异常。 try代码块后需要跟着catch代码块用于获取并处理抛出的异常。会进入第一个符合catch获取异常的代码块。 如果try语句有多层调用，会先找该层有没有适合的catch语句，再寻找上一层的，以此类推。如果都没有则会转到terminate的函数，导致程序非正常退出。 当然如果没有try还发生了异常会直接terminate。 12345try&#123; throw runtime_error(&quot;RE&quot;);&#125; catch(runtime_error err)&#123; ...&#125; 标准异常库 定义了以下几种异常类型 异常类型 内容 exception 常见异常 runtime_error 运行时异常 range_error RE:结果超出了有意义的值域 overflow_error RE:计算上溢 underflow_error RE:计算下溢 logic_error 逻辑错误 domain_error LE:参数对应结果不存在 invalid_argument LE:无效参数 length_error LE:创建一个超出该类型最大长度对象 out_of_range LE:使用超出有效范围的值 除了exception,bad_alloc,bad_cast对象不能提供初始值，其他异常类型需要提供一个字符串(string/const char*)初始化，用于提供该异常的错误相关信息。 异常的what成员函数返回该字符串初始值。不能返回的由编译器决定内容。 调试帮助 assert assert是一个宏。 代码assert(expr);的行为是先对expr求值，若expr为假，则输出信息并终止程序，若为真则什么都不做。 如果使用了#define定义了NDEBUG，则assert什么都不做。 一些变量 __func__:当前调试的函数名 __FILE__：当前文件名的字符串字面值 __LINE__:当前行号的int __TIME__:文件编译时间字符串字面值 __DATE__:文件编译日期字符串字面值 IO 头文件 &lt;iostream&gt; &lt;fstream&gt; &lt;sstream&gt; 流对象会有状态iostate。 rdstate()方法能获取流对象当前的状态。 setstate()设置状态 good()看流对象是否错误 clear()恢复错误状态 以及一堆东西用来管理。 缓冲区 输出流的内容可能会被输入到缓冲区中。等一个时间再写。 endl会插入一个换行然后刷新 flush刷新 ends插入一个空字符然后刷新 使用unitbuf操作符后会让流在之后的每次写操作后flush 用nounitbuf后恢复 关联 tie()方法传入一个类引用/指针。 如果输入流关联到输出流时，任何从输入流读数据的操作都会先刷新关联的输出流。 文件流 fstream 初始化fstream fs(s,mode);传入文件名s，打开为文件流。模式为mode，该参数可选。 open()方法，用fstream打开文件 close()方法，关闭文件流 is_open()方法，指出关联文件是否打开而且没有关闭。 ifstream和ofstream文件输入输出流。 如果open()失败了会置位failbit 可以直接if(fs)来检测是否打开成功。 流，文件模式 可以指定文件模式 文件模式 干嘛的 in 读方式 out 写方式 app 写操作前定位到文件末尾 ate 打开文件后定位到文件末尾 trunc 截断文件 binary 二进制io out模式只能设定给ofstream或者fstream in模式只能给ifstream fstream 没用trunc就可以用app 用ostream打开文件时文件内容会被扔掉 除非指定app模式 1ofstream out(&quot;a.txt&quot;, ofstream::out | ofstream::app); sstream stringstream用string初始化咯。 str()方法返回流保存string的拷贝 str(s)方法把s拷贝到流里边然后返回void 泛型 这部分感觉书的意思是stl风格的泛型算法？ 谓词 谓词是一个可以调用的表达式，其返回结果是一个能作为条件的值。 stl中接受一元或者二元谓词。 举个例子，sort()函数的重载之一，接受的第三个参数就是谓词。 也就是sort(it.begin(),it.end(),cmp)；中的cmp就是一个二元谓词，其是一个比较函数，返回bool类型。 lambda表达式 谓词接受的参数个数是严格确定的，但是有时候谓词的内容可能是高度相似的，这是重写多个谓词不太合理，又不能把这部分单独设置成一个函数参数，就该用lambda了。 12//结构[capture list](param list) -&gt; return type &#123;function body&#125; lambda表达式是一种可调用对象，函数，函数指针，以及重载了函数调用运算符的类也是可调用对象。 我们可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体。 忽略返回类型的时候返回类型是自动推断的。 1auto f = []&#123;return -1;&#125; 这时f就是一个可调用对象。 用f();来调用。 捕获列表 在捕获列表中添加变量名，lambda的函数体内才能访问这些变量。 123int a = 1;auto f = [a]() -&gt;int &#123;return a; &#125;;cout &lt;&lt; f(); 但是lambda的捕获列表是一如既往的延迟调用的。在定义的时候就复制了一份捕获列表内容。 12345 int a = 1; auto f = [a]() -&gt;int &#123;return a; &#125;; a=2; cout &lt;&lt; f();//依旧输出a 把列表内改为引用可以很显然地解决这个问题。 还有一些更抽象的用法（隐式捕获）： [=]可以捕获所有的变量 [&amp;]可以捕获所有变量的引用 f可以在别的函数里边定义： 1234567891011121314template &lt;typename T&gt;int func(T t) &#123; return int(t());&#125;int main() &#123; ios::sync_with_stdio(0); int a = 1; auto f = [&amp;a] &#123;return a; &#125;; cout&lt;&lt;func(f); a = 2; cout &lt;&lt; func(f);&#125;//输出1，2 可变lambda 要是想改变捕获的被拷贝的变量，要加上mutable关键字。 1234int a = 0;auto f = [a] () mutable &#123;return ++a;&#125;a = 10;f();//这时返回1，参数列表里边的a作为被拷贝变量被保存了。 感觉这个时候捕获列表复制之后，就变成了一个同名的作用域不一样的局部变量？ lambda就是可以就地声明匿名函数，让调用更加方便了！ 当然新写一个class重载()操作符搞一个仿函数也是一样的效果，大概。 bind函数 bind函数被定义在&lt;functional&gt;内。 作用是接受一个可调用对象以及一个参数列表，生成一个新的可调用对象来适应这些参数列表。 1auto newCallable = bind(callable , arg_list); 相当于调用newCallable的时候这玩意把arg_list里的参数传给callale _n占位符意味着newCallable里的第n个参数。 _n被定义在std::placeholders命名空间里边。 12345auto f1 = [](int a,int b)&#123; return a-b;&#125;auto f2 = bind(f1,2,_1);f(1);//返回2-1=1 迭代器 io流也有迭代器。 istream_iterator和ostream_iterator 泛型！ 要构造支持很多种类型的泛型算法，就需要用到迭代器，迭代器抽象了那些访问读写操作，程序只需要操作迭代器而不用关心传入的东西的类型。 输入迭代器(==,!=,++,*,-&gt;) 输出迭代器(++,**) 前向迭代器(支持多次扫描) 双向迭代器(支持正反读写,–) 随即访问迭代器(支持随即访问,能比较两个迭代器位置关系,+=，+，-，-=，下标[]等) 算法命名规范 除了传入首尾迭代器以外 使用重载来加入一个谓词参数： 12sort(beg, end);sort(beg, end, comp); _if版本 12find(beg, end, val);find_if(beg, end, perd);//第一个perd为真 _copy版本 用于区分拷贝版和非拷贝版本","categories":[{"name":"c++","slug":"c","permalink":"https://pophirasawa.top/categories/c/"}],"tags":[{"name":"语言","slug":"语言","permalink":"https://pophirasawa.top/tags/%E8%AF%AD%E8%A8%80/"}]},{"title":"速通形式语言与自动机","slug":"04学习/速通形式语言与自动机","date":"2022-05-28T16:00:00.000Z","updated":"2022-05-29T02:21:59.660Z","comments":true,"path":"2022/05/29/04学习/速通形式语言与自动机/","link":"","permalink":"https://pophirasawa.top/2022/05/29/04%E5%AD%A6%E4%B9%A0/%E9%80%9F%E9%80%9A%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"整蛊咯整蛊咯 基础知识 没啥p用 集合 集合的基数：有限集(不同元素个数)，无限集(等势，双射函数？) 可数集/不可数集：和自然数一一对应 逻辑 没什么好说的 图 图的定义：三元组(V,E,ψ)(V,E,\\psi)(V,E,ψ),点集、边集、边到两个端点集合的函数 子图、真子图、生成子图：生成子图有全部点集 略 证明技术 整蛊","text":"整蛊咯整蛊咯 基础知识 没啥p用 集合 集合的基数：有限集(不同元素个数)，无限集(等势，双射函数？) 可数集/不可数集：和自然数一一对应 逻辑 没什么好说的 图 图的定义：三元组(V,E,ψ)(V,E,\\psi)(V,E,ψ),点集、边集、边到两个端点集合的函数 子图、真子图、生成子图：生成子图有全部点集 略 证明技术 整蛊 语言及文法 终于开始学了 语言的定义与运算 字符集合：字母表，T（实际上是有限的） 定义：ϵ\\epsilonϵ空字符串 定义：T∗T^*T∗是所有字符串加空串的集合，T+T^+T+是所有字符串的集合 定义：语言L是T∗T^*T∗的子集，就是一些字符串的集合 定义：语言的乘积L1∗L2L_1*L_2L1​∗L2​是两者中的字符串连接构成的集合 定义：L的0次幂是空字符串 定义：L∗L^*L∗闭包，L+L^+L+正闭包，闭包0-n次幂的并，正闭包1-n次幂的并 文法 文法G：四元组G=(N,T,P,S) N 非终结符有限集 T 终结符有限集 P 生成式，“可被替代”的含义 S 起始符 约定： 字母表中排在前面的小写字母a，b，c 终结符 字母表中排在前面的大写字母A，B，C 非终结符 字母表中排在后面的大写字母X，Y，Z 文法符号（既可以是终结符，也可以是非终结符） 字母表中排在后面的小写字母u，v，……，z 终结符号串 小写的希腊字母α，β，γ 文法符号串 推导与句型：latex箭头忘了是啥，反正就是通过生成式把字符串代换导出。句型是N和T的闭包内容，句子是T的闭包内容。 文法分类 定义 1型：上下文有关 α→β,∣α∣&lt;=∣β∣\\alpha\\rightarrow\\beta,|\\alpha|&lt;=|\\beta|α→β,∣α∣&lt;=∣β∣ 2型：上下文无关 A→αA\\rightarrow\\alphaA→α 3型：正则 A→ωBA\\rightarrow\\omega BA→ωB，A→BωA\\rightarrow B\\omegaA→Bω右线性左线性 0型：0 2型文法各种表示法 BNF表示法：把左端相同的生成式合并，用|分隔，箭头用::=替代 语法图： A-&gt;A1A2A3 graph LR A(A1) --> B(A2) --> C(A3) A-&gt;abA graph LR A(A1) --> B((a)) --> C((b)) --> -out(out) C-->A 有限自动机和右线性文法 有限自动机 NFA，DFA：不确定和确定的有限状态自动机 疯狂地转移！ 形式定义：DFA五元组，M=(Q,T,δ,q0,F)M=(Q,T,\\delta,q_0,F)M=(Q,T,δ,q0​,F) Q 有限状态集合 T 有限输入字母表 δ\\deltaδ 转换函数 状态q，输入a到达状态p 写作δ(q,a)=p\\delta(q,a)=pδ(q,a)=p q0q_0q0​ 初始状态 F 终止状态集 L(M)：为M接受的语言，其实就是有向图走来走去呗 NFA NFA是一堆节点在一个树上跑，看哪个能最终接受，类似dfs一样。 多种可能性。 DFA和NFA 存在一个DFA和NFA等效。 子集构造法？ 带空串转换的NFA 存在无空串转换的NFA和有空串的NFA等效 看不懂证明 正则 定义：递归定义如下 空字符串和空集都是正则式 字母表中的字母是正则式 如果A，B都是正则式，那(A+B)，(A·B)，(A*)都是正则式 可以给定右线性文法算出正则式 规则R：设x=ax+b，其解x=a*b 解方程( 右线性文法和正则集 一个语言是正则集，当且仅当该语言为右线性语言 正则表达式和有限自动机 定理：L是正则表达式R表示的语言，则存在一个具有ϵ\\epsilonϵ转换的有限自动机接受语言L 扩充正则式： R是正则式，则R,R∗R,R^*R,R∗为扩充正则式 R+k,R∗kR^{+k},R^{*k}R+k,R∗k-&gt;R到R的k次幂的并，以及空集 若R1,R2R_1,R_2R1​,R2​为扩充正则式，则R1R2,R1+R2R_1R_2,R_1+R_2R1​R2​,R1​+R2​也是 可以通过正则式构建带空串转换的NFA 设R1，R2的两个NFA为M1，M2 R1+R2：并联 graph LR A(q0) --> B(q1) --M1--> C(qf1) --ε--> qf A(q0) --> D(q2) --M2--> E(qf2) --ε--> qf R1+R2：串联 graph LR A(q1) --M1--> C(qf1) --ε--> q2 q2--M2--> D(qf2) 定理：L被DFA接受，L可以用正则表达式表示","categories":[{"name":"课外","slug":"课外","permalink":"https://pophirasawa.top/categories/%E8%AF%BE%E5%A4%96/"}],"tags":[{"name":"自动机","slug":"自动机","permalink":"https://pophirasawa.top/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"JAVA快速入门(1)","slug":"04学习/JAVA快速入门(1)","date":"2022-04-24T20:30:00.000Z","updated":"2022-06-15T19:51:33.157Z","comments":true,"path":"2022/04/25/04学习/JAVA快速入门(1)/","link":"","permalink":"https://pophirasawa.top/2022/04/25/04%E5%AD%A6%E4%B9%A0/JAVA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(1)/","excerpt":"引言 为了应付大作业，特地速成一哈JVAV 省略了一堆东西 估计过几天会继续写后篇，到时候再看吧。 内容包括 语法快速入门（这玩意和cpp大部分很像所以没咋写） 面向对象基础 杂项 一些核心类 ？","text":"引言 为了应付大作业，特地速成一哈JVAV 省略了一堆东西 估计过几天会继续写后篇，到时候再看吧。 内容包括 语法快速入门（这玩意和cpp大部分很像所以没咋写） 面向对象基础 杂项 一些核心类 ？ 声明 和cpp不同的部分 12int[] a = new int[5]; //数组var a = new int[5]; //自动类型推导 ps. 任何数组都是引用类型！ string也是！ 实例化的对象也是！ 这时候要判断是不是相等要用 a.equals(b)的方法 这个时候赋值是引用类型参数绑定 感觉有点像指针。。还有那个python的原理 方法 可变参数 类似函数传入数组，用类型...定义 1234567class Group &#123; private String[] names; public void setNames(String... names) &#123; this.names = names; &#125;&#125; 传入可以直接传入多个string 构造方法 类构造时调用的方法 构造函数 可以重载 123class Group &#123; public Group&#123;&#125;&#125; 实例化 1A a = new A(); 类的一些东西 继承 java是单继承的，用extends关键字 12class B extends A&#123;&#125; 经典protected类型，令子类可以访问父类的内容 很显然，子类不应该定义和父类重名的字段，private也不行 super super代表了父类，super();即父类的构造方法 实例化类的时候，会默认调用一个无参的super(); 如果此时父类没有无参构造方法会报错 解决方法是手动在类构造函数上加一句父类对应的super(xxxx); 子类不会继承任何父类的构造方法 阻止继承 感觉暂时用不上 12public sealed class A permits B, C &#123;&#125; 用sealed和permits可以让只有指定的类才能继承该类 上/下转型 继承树object&gt;a&gt;b 向上： 直接用引用变量指向子类实例就行 1A a = new B(); 向下： 父类类型强转到子类类型 123A a = new B();B b = new B();b = (B)a; instanceof为操作符，判断一个东西是不是指定类型 123456789Object obj = &quot;hello&quot;;if (obj instanceof String) &#123; String s = (String) obj;&#125;//或者可以直接一起转型Object obj = &quot;hello&quot;;if (obj instanceof String s) &#123;// 可以直接使用变量s System.out.println(s.toUpperCase());&#125; 这种转型有时候我们在方法中传递形参为父类，又想调用子类的方法时，在确定了传入实参为子类后可以进行一个强转。 多态 override 首先说明方法签名： 方法名 参数列表 如果子类的一个方法方法签名和父类的完全一致，则子类会覆写父类的方法 使用@Override修饰，编译器还会帮助检查是否为覆写而非重载 @Override并非必须 java调用方法时根据的是对象真正的类型而不是引用的类型进行调用 多态 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法 如果调用父类被覆写了的方法 可以使用super.方法名()来调用 final 感觉类似const final修饰的类无法继承，final修饰的方法不会被覆写，final修饰的变量初始化之后无法更改 抽象类 类似cpp里边的虚函数，其实就是父类单纯提供方法签名而不实现任何功能，即抽象方法的时候用的。 这样就能构成多态。 使用abstract修饰就完了，定义了抽象方法的类也要一样地修饰，这就是抽象类 和cpp一样抽象类无法实例化 123abstract class Person &#123; public abstract void run();&#125; 所有这些东西的主要思想其实就是呃（抄的） 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 接口 接口本质是更抽象的抽象类 如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以用接口改写。 使用interface声明，这里边的东西直接默认是public abstract 1234interface A &#123; void run(); String asdf();&#125; 那么我们该如何使用这玩意呢 使用implements实现, 而且一个类可以实现多个接口 123class Student implements Person, Hello &#123; // 实现了两个interface ...&#125; 有关接口继承 这玩意看着好复杂… 一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。 我们还可以定义default方法， 这个相当于抽象类中有具体实现的那些方法。 这样继承这个接口的所有子类也可以直接用这个方法。 12345678910interface A &#123; void run(); default String asdf();&#125;class B implements A&#123; void run()&#123; asdf(); &#125;&#125; 一些杂项 静态字段 静态字段啥的跟cpp类里边的差不多，静态方法是可以直接用方法名调用，类似正常的函数，但是他显然不能访问实例的非静态字段 使用static修饰，懂得都懂（ 包 类似命名空间 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。 import 使用import语句，导入包中的类或者子包 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class） 还有一种import static的语法，它可以导入可以导入一个类的静态字段和静态方法。 作用域 感觉不用写。 一个是java支持嵌套类，内部的类也可以访问``private` 内部类 嵌套类，可以声明可以匿名 在方法内部定义一个匿名类，这玩意其实就是一个东西继承自某个父类，然后重写一下里边的方法？ 123Runnable r = new 父类类名() &#123; // 实现必要的抽象方法...&#125;; classpath和jar 不会 jar包相当于zip包，其实就是把编译好的一堆.class文件打包到一起便于管理 模块 应该是依赖管理之类的，懒得看了 JAVA的一些核心类 怎么都nm4点了，写完这段歇了（ String 1String s = &quot;eee&quot;; 首字母大写（ String不可变 由于是引用类型，我们要用s1.equals(s2)这种来判断是否相同 equalsIgnoreCase()方法忽略大小写比较 一堆方法啊。。 直接抄了。 123456789101112131415161718192021222324252627282930313233343536// 是否包含子串:&quot;Hello&quot;.contains(&quot;ll&quot;); // true&quot;Hello&quot;.indexOf(&quot;l&quot;); // 2&quot;Hello&quot;.lastIndexOf(&quot;l&quot;); // 3&quot;Hello&quot;.startsWith(&quot;He&quot;); // true&quot;Hello&quot;.endsWith(&quot;lo&quot;); // true&quot;Hello&quot;.substring(2); // &quot;llo&quot;&quot;Hello&quot;.substring(2, 4); //&quot;ll&quot;// 使用trim()方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n：&quot; \\tHello\\r\\n &quot;.trim(); // &quot;Hello&quot;&quot;&quot;.isEmpty(); // true，因为字符串长度为0&quot; &quot;.isEmpty(); // false，因为字符串长度不为0&quot; \\n&quot;.isBlank(); // true，因为只包含空白字符&quot; Hello &quot;.isBlank(); // false，因为包含非空白字符String s = &quot;hello&quot;;s.replace(&#x27;l&#x27;, &#x27;w&#x27;); // &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;s.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;replace还支持正则，没学过 String[] arr = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot;String.valueOf(123); // &quot;123&quot;String.valueOf(45.67); // &quot;45.67&quot;String.valueOf(true); // &quot;true&quot;String.valueOf(new Object()); // 类似java.lang.Object@636be97cchar[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[]String s = new String(cs); // char[] -&gt; String 还要byte字符串编码啥的，这玩意我感觉需要就火速百度就完了。 StringBuilder String可以直接用+拼接，但是效率不高。 如果要一直添加字符的话可以用这个玩意 123456StringBuilder sb = new StringBuilder(1024);for (int i = 0; i &lt; 1000; i++) &#123; sb.append(&#x27;,&#x27;); sb.append(i);&#125;String s = sb.toString(); 支持链式操作，就是说可以一直.append().append()...之类的 还有个insert方法，要给插入的index和内容 不过链式操作只要函数结束之后返回对象引用就行了吧（ 谁叫这玩意啥都是引用 包装类型 意思就是类似int这种基本类型用类进行了包装，可以使用引用和一些奇奇怪怪的方法。 进行一个抄 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character int的转换示例 123456int i = 100;Integer n = Integer.valueOf(i);int x = n.intValue();你甚至可以这么写Integer n = 100; // 编译器自动使用Integer.valueOf(int)int x = n; // 编译器自动使用Integer.intValue() 很显然这个Integer.valueOf(i)是静态方法，而且这玩意实现有优化，比new Integer(i)效率更高，因为他返回给引用的可能是以前就已经存在的实例 当然，这些B东西都是不可更改的。。 静态方法parseInt()可以把字符串解析成一个整数 枚举类 例如我要定义周一到周日这7天，而且我不想让这7天以外的符号和他进行操作，就可以用enum关键字声明 12345678910111213enum Weekday &#123; SUN, MON, TUE, WED, THU, FRI, SAT;&#125;本质来说感觉是这样，别问为啥例子变了，我也不知道public final class Color extends Enum &#123; // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() &#123;&#125;&#125; 我个人感觉这些其实就是抽象符号，而且拥有static final的属性 这样就不会有类型外的值和非枚举类内的值相互比较了 因为有static的属性，我们显然可以用==进行比较 有方法name()返回常量名 1String s = Weekday.SUN.name(); // &quot;SUN&quot; ordinal()返回定义的常量的顺序，从0开始计数 1int n = Weekday.MON.ordinal(); // 1 既然这玩意本质是类，我们也可以在里边改写构造方法，给它加上一些值 123456789enum Weekday &#123; MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0); public final int dayValue; private Weekday(int dayValue) &#123; this.dayValue = dayValue; &#125;&#125; 这样我们可以访问引用的daValue值获得信息。。 记录类 用来记录数据的不变类，写的更方便 1public record A(int x, int y)&#123;&#125; 可以改写构造方法加上判断 BigInteger 高精度，用它给你的方法就完了。 实例化的时候要用字符串 BigDecimal 和上边那个差不多呃 通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal 工具类 Math：数学计算 Random：生成伪随机数 SecureRandom：生成安全的随机数 呃这个感觉没啥好说的 Math 12345678910111213141516171819202122Math.abs(-100); // 100Math.abs(-7.8); // 7.8Math.max(100, 99); // 100Math.min(1.2, 2.3); // 1.2Math.pow(2, 10); // 2的10次方=1024Math.sqrt(2); // 1.414...Math.exp(2); // 7.389...Math.log(4); // 1.386...Math.log10(100); // 2Math.sin(3.14); // 0.00159...Math.cos(3.14); // -0.9999...Math.tan(3.14); // -0.0015...Math.asin(1.0); // 1.57079...Math.acos(1.0); // 0.0double pi = Math.PI; // 3.14159...double e = Math.E; // 2.7182818...Math.sin(Math.PI / 6); // sin(π/6) = 0.50-1Math.random(); // 0.53907... 每次都不一样 Random 1234567Random r = new Random(种子);r.nextInt(); // 2071575453,每次都不一样r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的doubler.nextBytes(); SecureRandom 1SecureRandom sr = new SecureRandom(); 然后疯狂的用就完了 DONE！！！！！","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://pophirasawa.top/categories/JAVA/"}],"tags":[{"name":"语言","slug":"语言","permalink":"https://pophirasawa.top/tags/%E8%AF%AD%E8%A8%80/"}]},{"title":"回文树","slug":"01或许是算法/回文树","date":"2022-03-22T14:06:26.000Z","updated":"2022-03-22T15:19:02.083Z","comments":true,"path":"2022/03/22/01或许是算法/回文树/","link":"","permalink":"https://pophirasawa.top/2022/03/22/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%96%87%E6%A0%91/","excerpt":"久违的学一点点东西得了。。。 简而言之 回文树是一种用来处理回文的自动机,可以处理一个字符串中的所有不同子串 指路论文：https://victorwonder.blog.uoj.ac/blog/146","text":"久违的学一点点东西得了。。。 简而言之 回文树是一种用来处理回文的自动机,可以处理一个字符串中的所有不同子串 指路论文：https://victorwonder.blog.uoj.ac/blog/146 首先 我们有这么一个结论： 一个长为n字符串中最多存在n个本质不同的回文子串 每次加入一个字符，假设生成了1个以上的本质不同回文子串 考虑生成的最长的和最短的回文子串A、B，那么有两种可能 B的左端点在A的中点右边：由于B为回文串，则A中点左侧必定存在一个与B相同的回文串，矛盾 B的左端点在A的中点左边：由于A为回文串，则B截去超出中点的镜像部分在A中点左侧必定存在相同的串，矛盾 因此每次加入一个字符生成本质不同回文子串最多一个 然后 我们就可以开始构造这个回文树了 如果这个图没有挂的话， 我们可以看出，这个玩意和sam啥的都很像，就是由转移边和fail指针（后缀link）组成的。 两个起始状态奇根和偶根就是用来存长度为奇数的回文串和长度为偶数的回文串 后缀link就是指向当前回文串的最长回文后缀。 具体 和那些奇奇怪怪的自动机一样，我们每次都加入一个字符。 假设已经处理了的串为s，我们要加入一个新的字符X，那么该怎么办呢？ 首先我们找到串s的最长后缀回文串t（这玩意已经提前维护好了） 那么如果s的最后一段长成xtx这样，那么显然这玩意就是新串的最长回文后缀，然后我们还可以试图更新一下状态啥的 那如果不是呢 聪明的你一定想到了：肯定要用到后缀link呗， 不然哥们维护他干嘛 确实，只要找t的后缀link到的各个节点，一个个试即可，最后大不了到奇根。变成长度为1的回文子串即可。 一个小问题： 新出现的状态后缀link该往哪里连？ 很显然，新状态的最长回文后缀也是Xt’X的形式，从新出现的状态接着往下找一找就完事了 这个理论上应该存在的图就很好的说明了整个流程 最后 喜闻乐见的代码时间！ 板子，开超！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct PAM&#123; int nex[maxn][26]; //指向的一个字符的节点 int fail[maxn]; //失配节点 int len[maxn]; //当前节点回文长度 int str[maxn]; //当前字符串 int cnt[maxn]; //节点出现次数 int last; //目前走到哪个节点 int tot; //PAM中节点数 int N; //添加的串的个数 int newnode(int L)&#123; //新建节点 for(int i = 0; i &lt; 26; i++) nex[tot][i] = 0; len[tot] = L; cnt[tot] = 0; return tot++; &#125; void init()&#123; tot = 0; newnode(0); newnode(-1); last = 0; N = 0; str[0] = -1; fail[0] = 1; //偶根指向奇根，因为到奇根必匹配 &#125; int getfail(int x)&#123; //失配 while(N - len[x] - 1 &lt; 0 || str[N - len[x] - 1] != str[N]) x = fail[x]; return x; &#125; void add(char ss)&#123; int c = ss - &#x27;a&#x27;; str[++N] = c; int cur = getfail(last); //最长可扩增的后缀回文节点 if(!nex[cur][c])&#123; int now = newnode(len[cur] + 2); fail[now] = nex[getfail(fail[cur])][c]; //cur后缀(除自己)的最长的能让now失配的后缀 nex[cur][c] = now; &#125; last = nex[cur][c]; cnt[last]++; &#125; void count()&#123; for(int i = tot - 1; i &gt;= 0; i--) //子节点出现父节点也出现 cnt[fail[i]] += cnt[i]; &#125;&#125;pam;","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"回文","slug":"回文","permalink":"https://pophirasawa.top/tags/%E5%9B%9E%E6%96%87/"}]},{"title":"2022 winter training 1-H","slug":"03久远时光以前的补题记录/寒假补题1-H","date":"2022-01-12T10:23:23.000Z","updated":"2022-01-12T10:32:52.631Z","comments":true,"path":"2022/01/12/03久远时光以前的补题记录/寒假补题1-H/","link":"","permalink":"https://pophirasawa.top/2022/01/12/03%E4%B9%85%E8%BF%9C%E6%97%B6%E5%85%89%E4%BB%A5%E5%89%8D%E7%9A%84%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/%E5%AF%92%E5%81%87%E8%A1%A5%E9%A2%981-H/","excerpt":"摆了，但是没有完全摆 CF103495H H. Reverse the String 给定长1e5的字符串，你可以翻转其中一段连续子段，问能产生的字典序最小的字符串是啥 据说可以用SA写，我是没啥思路，题解是hash，就这样补了","text":"摆了，但是没有完全摆 CF103495H H. Reverse the String 给定长1e5的字符串，你可以翻转其中一段连续子段，问能产生的字典序最小的字符串是啥 据说可以用SA写，我是没啥思路，题解是hash，就这样补了 思路 考虑把字符串的字符排序，生成的新字符串必然是字典序最小的构造。 那么我们从原字符串和新字符串第一个不同的点作为翻转的起点即可。 然后枚举右端点，通过二分hash，求lcp来比较字符串大小即可。 hash的话，正反跑一遍拼起来就完了，不过式子有一点折磨捏 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;unordered_map&gt;#include &lt;iomanip&gt;#include&lt;set&gt;typedef long long ll;typedef unsigned long long ull;using namespace std;char s[200000 + 5];char s2[200000 + 5];ll seed = 20111203;ll mod = 1e9 + 7;ll T;ll h[200000 + 5];ll r[200000 + 5];ll poww[200000 + 5];ll l;ll q(ll L, ll R, ll x) &#123; if (x &lt; L)return h[x]; if (x &gt; R)return ((h[L - 1] * poww[x - L + 1])%mod +(r[L] - r[R+1] * poww[R - L + 1]%mod+mod)%mod * poww[x - R]%mod + (h[x] - (ull)h[R] * poww[x - R]%mod +mod)%mod)%mod; else return (h[L - 1] * poww[x - L + 1]%mod + (r[R-(x-L)] - r[R+ 1] * poww[(x - L)+1]%mod+mod)%mod)%mod;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(NULL); poww[0] = 1; for (int i = 1; i &lt;= 100000 + 5; i++) &#123; poww[i] = poww[i - 1] * seed%mod; &#125; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; s + 1; l = strlen(s+1); for (int i = 1, j = l; i &lt;= l &amp;&amp; j &gt;= 1; i++,j--) &#123; h[i] =( h[i - 1] * seed%mod + s[i] - &#x27;a&#x27;)%mod; r[j] = (r[j + 1] * seed%mod + s[j] - &#x27;a&#x27;)%mod; s2[i] = s[i]; &#125; sort(s2 + 1, s2 + 1 + l); ll r1 = 0; for (int i = 1; i &lt;= l; i++) &#123; if (s[i] == s2[i])r1 = i; else break; &#125; r1++; //cout &lt;&lt; q(2, 4, 2); if (r1 &gt; l)cout &lt;&lt; s + 1 &lt;&lt; &#x27;\\n&#x27;; else &#123; ll mx = r1; for (int i = r1; i &lt;= l; i++) &#123; ll L = 0, R = l; while (L&lt;R) &#123; ll m = L + R &gt;&gt; 1; if (q(r1, i, m) == q(r1, mx, m))L = m+1; else R = m; &#125; if (L &gt; l)continue; if (q(r1, i, L) &lt; q(r1, mx, L))mx = i; &#125; for (int i = 1; i &lt; r1; i++)cout &lt;&lt; s[i]; for (int i = mx; i &gt;= r1; i--)cout &lt;&lt; s[i]; for (int i = mx + 1; i &lt;= l; i++)cout &lt;&lt; s[i]; cout &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;","categories":[{"name":"补题","slug":"补题","permalink":"https://pophirasawa.top/categories/%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://pophirasawa.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Super Star Spectacle","slug":"A","date":"2022-01-11T17:09:00.000Z","updated":"2022-01-11T17:16:50.241Z","comments":true,"path":"2022/01/12/A/","link":"","permalink":"https://pophirasawa.top/2022/01/12/A/","excerpt":"","text":"列车一定会去往下一站，而舞台少女，将会前往下个舞台。","categories":[],"tags":[]},{"title":"wi(l)d-screen baroque","slug":"Q","date":"2022-01-11T16:52:30.000Z","updated":"2022-01-11T17:31:33.217Z","comments":true,"path":"2022/01/12/Q/","link":"","permalink":"https://pophirasawa.top/2022/01/12/Q/","excerpt":"","text":"列车一定会去往下一站。那么舞台呢？我们呢？","categories":[],"tags":[]},{"title":"鸽巢原理","slug":"04学习/鸽巢原理","date":"2022-01-09T17:10:00.000Z","updated":"2023-04-06T17:54:45.515Z","comments":true,"path":"2022/01/10/04学习/鸽巢原理/","link":"","permalink":"https://pophirasawa.top/2022/01/10/04%E5%AD%A6%E4%B9%A0/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/","excerpt":"内容 鸽巢原理及其一些推论，包括但不限于 简单形式 中国剩余定理 加强形式 Ramesy定理 呃呃","text":"内容 鸽巢原理及其一些推论，包括但不限于 简单形式 中国剩余定理 加强形式 Ramesy定理 呃呃 简单形式 n+1个物品放入n个盒子中，至少存在一个盒子中存在多个物品 可以抽象表示为: 令X，Y为两有限集，令f为一个从X到Y的函数 若X的元素大于Y的元素，则f不是一对一的 若X和Y有相同个数的元素，且f是映上的，则f是一对一的 若X和Y有相同个数的元素，且f是一对一的，则f是映上的 然后就可以发展出一些应用了 推论：中国剩余定理 令m和n为互素的正整数，有正整数a、b，且a不大于m-1，b不大于n-1。则存在x，x mod m = a，x mod n = b。 证明：先得出在a，a+m，a+2m，…(n-1)m+a中mod n没有相同的余数。因此n个数中0到n-1每个数都作为余数出现。那对与b也存在对应的p令pm+a mod n = b Ramsey定理 在6个人中，或有三个人他们彼此互相都认识，或有三个人，他们中两两都彼此不认识。 也就是说： 考虑一个6个点的无向完全图，将边染成两种颜色。那么必定存在一个三角形三条边为相同的颜色。 也可以表示为 K6→K3,K3K_6\\rightarrow K_3,K_3 K6​→K3​,K3​ 更一般的定义如下： m，n为两个不小于2的整数，那么将存在一个正整数p，令$$K_P \\rightarrow K_m,K_n$$ Ramsey数r(m,n)为令等式成立的最小整数p 有定理 r(2,n)=n以及r(m,2)=m 可以往更高维推广。。。","categories":[{"name":"组合数学","slug":"组合数学","permalink":"https://pophirasawa.top/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Goodbye 2021","slug":"03久远时光以前的补题记录/2021-01-6","date":"2022-01-06T14:33:22.000Z","updated":"2022-01-06T17:13:10.130Z","comments":true,"path":"2022/01/06/03久远时光以前的补题记录/2021-01-6/","link":"","permalink":"https://pophirasawa.top/2022/01/06/03%E4%B9%85%E8%BF%9C%E6%97%B6%E5%85%89%E4%BB%A5%E5%89%8D%E7%9A%84%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/2021-01-6/","excerpt":"2021年就这么结束了，不管是失败还是悲伤还是焦虑，亦或者是欢乐还是欣喜还是怀念，都已经过去了。 可能会写点文字来怀念？ 不过现在应该做的事情只有一件 补题。","text":"2021年就这么结束了，不管是失败还是悲伤还是焦虑，亦或者是欢乐还是欣喜还是怀念，都已经过去了。 可能会写点文字来怀念？ 不过现在应该做的事情只有一件 补题。 D. Keep the Average High 将式子变形一下 al+al+1+…+ar≥x⋅(r−l+1)⇒(al−x)+(al+1−x)+…+(ar−x)≥0a_l + a_{l+1} + \\ldots + a_r \\geq x \\cdot (r - l + 1) \\Rightarrow (a_l - x) + (a_{l+1} - x) + \\ldots + (a_r - x) \\geq 0al​+al+1​+…+ar​≥x⋅(r−l+1)⇒(al​−x)+(al+1​−x)+…+(ar​−x)≥0 然后就是挑一些最多的数让他满足所有连续子段和非负 然后就有一个很nb的结论 要满足上边的条件 只需要所有长度为2和3的子段满足条件即可 可以这样考虑： 所有长度大于2或者3的子段都可以拆成一些2和3不相交子段的和 稍微想一下奇偶应该就可以懂了 然后我们是不是就可以用用DP了呢（ 1dp[N][2][2];//dp数组，第一位表示到第i个能选的最大数量，第二位表示前一个有没有选，第三位表示当前位有没有选 转移就直接看代码吧 巨巧妙 反正我这个智力是不太能想到的（ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;unordered_map&gt;typedef long long ll;using namespace std;ll T;ll n;ll x;ll dat[50000 + 5];ll dp[50000 + 5][2][2];int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)cin &gt;&gt; dat[i]; cin &gt;&gt; x; for (int i = 0; i &lt; n; i++)dat[i] -= x; memset(dp, 0, sizeof(dp)); dp[0][0][1] = 1; for (int i = 1; i &lt; n; i++) &#123; dp[i][0][0] = max(dp[i - 1][0][0], dp[i - 1][1][0]); dp[i][0][1]=1LL+ max(dp[i - 1][0][0], dp[i - 1][1][0]); dp[i][1][0] = max(dp[i - 1][0][1], dp[i - 1][1][1]); if (dat[i - 1] + dat[i] &gt;= 0) &#123; dp[i][1][1] = 1LL + dp[i-1][0][1]; if (i &gt; 1 &amp;&amp; dat[i - 2] + dat[i - 1] + dat[i] &gt;= 0) &#123; dp[i][1][1] = max(dp[i][1][1], 1 + dp[i - 1][1][1]); &#125; &#125; &#125; ll ans = max(dp[n - 1][0][0], max(dp[n - 1][0][1], max(dp[n - 1][1][0], dp[n - 1][1][1]))); printf(&quot;%lld\\n&quot;, ans); &#125;&#125; E. Lexicographically Small Enough 这B题说简单不简单，说难不难 但是我看题解都想了好久 我是废物！ 给你个字符串s和字符串t 可以交换相邻的s字符，问最少次数令s字典序比t小 其实他的本质就是让s按照某种意义重新排序，然后问冒泡排序的交换次数呗 用树状数组维护逆序对 然后对于每个t[i]我们有两种思路 一种是直接从i后边拉一个比t[i]小的字符直接结束 一种是拉一个最近的和t[i]一样的字符 维护一个cur是到当前令其前缀相同的花费 然后我从后边拉字符他的花费其实就是逆序对 我们就可以跑贪心了 也许 这玩意数据太大了 ans设成1e9+7居然都会挂掉 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;unordered_map&gt;typedef long long ll;using namespace std;ll T;ll n;ll x;vector&lt;ll&gt;pos[26];ll sum[100000 + 5];char s[100000 + 5], t[100000 + 5];ll lob(ll i) &#123; return i &amp; -i;&#125;void init() &#123; for (int i = 0; i &lt;= n; i++)sum[i] = 0;&#125;void add(ll i) &#123; for (; i &lt; n; i = i | (i + 1)) &#123; sum[i] += 1; &#125;&#125;ll q(ll i) &#123; ll res = 0; for (;i&gt;=0; i=(i &amp; (i + 1)) - 1) res += sum[i]; return res;&#125;int main() &#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; init(); cin &gt;&gt; s&gt;&gt;t; for (int i = 0; i &lt; 26; i++)pos[i].clear(); for (int i = 0; i &lt;n; i++)pos[s[i] - &#x27;a&#x27;].push_back(i); for (int i = 0; i &lt; 26; i++)reverse(pos[i].begin(),pos[i].end()); ll ans = 1e11 + 7; ll cur = 0; for (int i = 0; i &lt;n; i++) &#123; ll c = t[i] - &#x27;a&#x27;; ll m = 1e11+7; for (int j = 0; j &lt; c; j++) &#123; if (pos[j].empty())continue; m = min(m, pos[j].back()); &#125; if (m &lt;n) ans = min(ans, cur + m - q(m)); if (pos[c].empty())break; m = pos[c].back(); cur += m - q(m); pos[c].pop_back(); add(m); &#125; if (ans == 1e11 + 7)printf(&quot;-1\\n&quot;); else printf(&quot;%lld\\n&quot;, ans); &#125;&#125;","categories":[{"name":"补题","slug":"补题","permalink":"https://pophirasawa.top/categories/%E8%A1%A5%E9%A2%98/"}],"tags":[]},{"title":"sam相关","slug":"01或许是算法/sam相关题目","date":"2021-11-24T18:43:31.000Z","updated":"2021-11-26T13:09:57.826Z","comments":true,"path":"2021/11/25/01或许是算法/sam相关题目/","link":"","permalink":"https://pophirasawa.top/2021/11/25/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/sam%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/","excerpt":"学完了这阴间玩意肯定得知道这玩意怎么用吧 sam理论上可以 子串endpos大小 子串endpod位置 在后缀link上跑dp 在自动机上跑dp 统计有多少个子串经过一个点 二分","text":"学完了这阴间玩意肯定得知道这玩意怎么用吧 sam理论上可以 子串endpos大小 子串endpod位置 在后缀link上跑dp 在自动机上跑dp 统计有多少个子串经过一个点 二分 然后就是题目呗 P3975 [TJOI2015]弦论 给定字符串，求找到字典序第k大的子串 有两种询问：相同子串就算1个和每个子串都算一个的 首先把endpos大小跑出来 如果相同子串只算1个，那么子串到每个状态的贡献只有1，不然就是endpos大小。endpos大小可以把状态按len排序然后从大到小更新就行。 然后跑一下dfs，统计从点i开始的有多少个字符串 最后按字典序从自动机上跑就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const ll MAXN =6e5 + 500;string s;ll k, t;struct NODE &#123; int ch[26] = &#123;&#125;; ll fa = 0, len = 0; //NODE() &#123; memset(ch, 0, sizeof(ch)); fa = 0, len = 0; &#125;&#125;sam[MAXN &lt;&lt; 1];ll lst = 1, tot = 1;ll f[MAXN &lt;&lt; 1];bool vis[MAXN &lt;&lt; 1];ll sz[MAXN &lt;&lt; 1];ll A[MAXN &lt;&lt; 1];void add(ll c) &#123; ll p = lst; ll np = lst = ++tot; f[np] = 1; sam[np].len = sam[p].len + 1; for (; p &amp;&amp; !sam[p].ch[c]; p = sam[p].fa)sam[p].ch[c] = np; if (!p)sam[np].fa = 1; else &#123; ll q = sam[p].ch[c]; if (sam[q].len == sam[p].len + 1)sam[np].fa = q; else &#123; ll nq = ++tot; sam[nq] = sam[q]; sam[nq].len = sam[p].len + 1; sam[q].fa = sam[np].fa = nq; for (; p &amp;&amp; sam[p].ch[c] == q; p = sam[p].fa)sam[p].ch[c] = nq; &#125; &#125;&#125;ll dfs(ll p) &#123; if (vis[p])return sz[p]; vis[p] = 1; ll tmp = f[p]; for (int i = 0; i &lt; 26; i++) if (sam[p].ch[i]) tmp += dfs(sam[p].ch[i]); return sz[p] = tmp;&#125;void solve(ll p) &#123; if (k &gt; sz[p]) &#123; printf(&quot;%d&quot;, -1); return; &#125; if (k &lt;= f[p])return; k -= f[p]; for (int i = 0; i &lt; 26; i++) &#123; if (!sam[p].ch[i])continue; if (sz[sam[p].ch[i]] &lt; k)k -= sz[sam[p].ch[i]]; else &#123; printf(&quot;%c&quot;, i + &#x27;a&#x27;); solve(sam[p].ch[i]); return; &#125; &#125;&#125;bool cmp(ll &amp;a, ll &amp;b) &#123; return sam[a].len &lt; sam[b].len;&#125;int main() &#123; cin &gt;&gt; s; for (int i = 0; i &lt; s.length(); i++) &#123; add(ll(s[i]) - &#x27;a&#x27;); &#125; scanf(&quot;%lld %lld&quot;, &amp;t, &amp;k); if (t == 0) for (int i = 2; i &lt;= tot; i++)f[i] = 1; else &#123; for (int i = 0; i &lt;= tot; i++)A[i] = i; sort(A + 1, A + tot + 1, cmp); for (int i = tot; i &gt; 0; i--)f[sam[A[i]].fa] += f[A[i]]; &#125; f[1]=f[0] = 0; dfs(1); solve(1);&#125; SPOJ1811 求两个字符串里最长公共子串长度 把s建成后缀自动机 然后把t的前缀挨个加进去，其实就是看t的前缀的后缀能在s里最长是多少 假设当前t加入的字符是c，当前状态是v，若v有c的出边，ans直接++ 如果没有，就一直找v的后缀link到有c的出边为止，ans=len+1了 如果这玩意到了0状态，就把他设回源点状态，ans=0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;string&gt;using namespace std;typedef long long ll;const ll MAXN = 5e5 + 5;struct NODE&#123; int ch[26] = &#123;&#125;; int len, fa;&#125;sam[MAXN &lt;&lt; 1];ll lst = 1, tot = 1;string s1, s2;void add(ll c) &#123; ll p = lst; ll np = lst = ++tot; sam[np].len = sam[p].len + 1; for (; p &amp;&amp; !sam[p].ch[c]; p = sam[p].fa)sam[p].ch[c] = np; if (!p)sam[np].fa = 1; else &#123; ll q = sam[p].ch[c]; if (sam[q].len == sam[p].len + 1)sam[np].fa = q; else &#123; ll nq = ++tot; sam[nq] = sam[q]; sam[nq].len = sam[p].len + 1; sam[q].fa = sam[np].fa = nq; for (; p &amp;&amp; sam[p].ch[c] == q; p = sam[p].fa)sam[p].ch[c] = nq; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; s1 &gt;&gt; s2; ll ans = 0; for (int i = 0; i &lt; s1.length(); i++)add(s1[i] - &#x27;a&#x27;); ll v = 1, l = 0;; for (int i = 0; i &lt; s2.length(); i++) &#123; ll tmp = s2[i] - &#x27;a&#x27;; if (sam[v].ch[tmp]) &#123; v = sam[v].ch[tmp]; l++; &#125; else &#123; for (; v &amp;&amp; !sam[v].ch[tmp]; v = sam[v].fa); if (v == 0) &#123; l = 0, v = 1; &#125; else &#123; l = sam[v].len + 1; v = sam[v].ch[tmp]; &#125; &#125; ans = max(ans, l); &#125; cout &lt;&lt; ans;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/tags/SAM/"}]},{"title":"后缀自动机","slug":"01或许是算法/sam","date":"2021-11-19T18:08:36.000Z","updated":"2022-01-03T12:59:54.281Z","comments":true,"path":"2021/11/20/01或许是算法/sam/","link":"","permalink":"https://pophirasawa.top/2021/11/20/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/sam/","excerpt":"这玩意就是SAM的原理以及基本板子了，大概，说不定再来一点套路总结吧 总的来说，这玩意拖的也太久了，一直说要学，然后狂摸不止，我 有罪！ 欸嘿","text":"这玩意就是SAM的原理以及基本板子了，大概，说不定再来一点套路总结吧 总的来说，这玩意拖的也太久了，一直说要学，然后狂摸不止，我 有罪！ 欸嘿 介绍 首先后缀自动机 可以包括给定字符串的所有子串 O(n) 是自动机 一些定义 endpos 字符串s的一个子串t，endpos(t)为s中t的所有结束位置构成的集合 SAM是一个最小的DFA 有向无环图 节点是状态，边是转移 转移是一些字母 从源点出发到终止状态所有转移连起来的字符串t是字符串s的一个后缀 SAM的节点最小 那么如果endpos(t1)=endpos(t2)，那么他们就在一个等价类中 一堆引理 两个非空子串u，w (|u|&lt;=|w|) endpos相同，只有u在s中每次出现都是以w的后缀出现的 那么就可以推出来： 考虑u，w (|u|&lt;=|w|) 只有2种可能 endpos(u),endpos(w)不相交 endpos(w)是endpos(u)的子集 一个endpos等价类里边，所有子串长度不同，而且差值为1，正好覆盖区间 然后就有我们的后缀link 对于一个不是源点的状态v，然后考虑这个endpos等价类中最长的字符串w，其他的就是w后缀了捏 然后我们有 w开始，有一个连续区间长度的后缀也都是这个等价类里边的玩意，定义最长的一个不是等价类里边的后缀为t，把v的后缀link到t上 显然最后是link到源点的 最后这玩意就构成了一个树 然后我们就可以开始算法本身了捏 算法实现 哥们看不懂捏 首先说重点 后缀link树和后缀自动机共同相同的节点，不同的只是转移的边不同 大概步骤 首先，这个是在线算法，我们每次往自动机里加入一个字符，然后维护SAM 首先定义初始状态 这个点编号0，len=0，fa=0 然后我们就能挨个加入字符c了 有以下流程 首先我们加入了一个新字符，那么新串对应的的endpos是新的长度，以前不存在，因此我们新建一个状态np，之前整个旧串对应的状态记为p，很显然len(q)=len§+1 然后对于新加入的字符c，我们进行以下操作 如果p没有一个字符c的出边(这里是自动机的边)，就在link树上到他的父节点，也就是后缀link的点，一直循环直到p到达初始状态的节点或者有一个字符c的出边 这个操作其实是压缩遍历旧串的所有后缀x，然后看是否存在一个x+c在旧串种就存在了，因为引理中已经提到，每个状态link到的节点都是当前状态的后缀，所有我们从p上来肯定是旧串的后缀了捏 途中我们把经过每个没有c出边的p都连一个c到np 然后我们就有3种情况 Case 1 p到初始状态都没有c的出边 np状态直接link到初始状态 Case 2 找到了一个p，有c的出边，到达一个新状态q，且len( q )=len( p )+1 首先我们知道p是旧串后缀，q是p的字符串+c，因此q是新串的后缀，那么我们理所当然把np link 到q上就行了 Case 3 和case2差不多，但是找到的p出边到达的q没有len( q )=len( p )+1 或者说，len( q )&gt;len( q )+1 这时候我们要把q拆成两个点，是新串后缀的和不是的，然后link就行 具体来说，定义一个新点nq，len=len§+1,出边转移和q相同，link 到p上，然后np和q都link到nq上 最后稍微更新下转移边，p往上走，把所有p link 到q的转移 link 到nq上就行了 最后稍微提一下如何计算每个状态的endpos大小 设想一下，我们每次加入一个字符c，肯定会出现一个新的endpos，而且他能够对往上走到源点经过的所有节点都产生影响，也就是说我们使用一个数组f[i]来统计endpos，加入新字符时让f[np]=1,最后跑一下dfs，f[i]=f[i]+sum(f[i所有的儿子]) 即可捏 或者把sam的点按len排序(可以用桶排) 从大到小更新 **f[sam[i].fa]+=f[i]**也行 code 先贴一手毛的板子 1234567891011121314151617181920212223242526struct NODE&#123; int ch[26]; int len,fa; NODE()&#123;memset(ch,0,sizeof(ch));len=0;&#125;&#125;sam[MAXN&lt;&lt;1];int lst=1,tot=1;void add(int c)&#123; int p=lst;int np=lst=++tot; sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa)sam[p].ch[c]=np; if(!p)sam[np].fa=1;//以上为case 1 else &#123; int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1)sam[np].fa=q;//以上为case 2 else &#123; int nq=++tot;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa)sam[p].ch[c]=nq;//以上为case 3 &#125; &#125;&#125; 暂时先写这么多，乏了，早上写一手题以及用法吧","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/tags/SAM/"}]},{"title":"维护区间众数","slug":"01或许是算法/维护区间众数","date":"2021-11-10T09:32:12.000Z","updated":"2021-11-16T15:34:34.532Z","comments":true,"path":"2021/11/10/01或许是算法/维护区间众数/","link":"","permalink":"https://pophirasawa.top/2021/11/10/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/","excerpt":"这玩意好像方法挺多的，然后今天被一个阴间东西坑了，来说一哈 其实就是给一个数列，然后给一堆询问，问你区间众数是多少吧","text":"这玩意好像方法挺多的，然后今天被一个阴间东西坑了，来说一哈 其实就是给一个数列，然后给一堆询问，问你区间众数是多少吧 首先先把我之前的复制一手啊 绝对众数问题 就是出现个数超过n/2的众数 这个我们可以用一个摩尔投票的方法来写捏 摩尔投票 首先考虑一个序列，里面两两取数，如果一样就留下，不一样就两个数都消掉，那么最后留下的数肯定就是数量超过n/2的数 实现的话，用两个变量cur和cnt，如果当前的数和cur不同且cnt==0 cur变为当前数，否则cnt– 如果相同 cnt++ 最后cur就是唯一有可能是绝对众数的数，然后跑一遍确认即可 123456789101112ll dat[maxn];ll majorityElement()&#123; ll cnt=1,cur=dat[0]; for(int i=1;i&lt;n;i++)&#123; if(dat[i]!=cnt)cnt--; else cnt++; if(cnt&lt;0)&#123; cut=dat[i]; cnt=0; &#125; &#125;&#125; 如果是n/3以至于n/k 其实就是设置多组cur和cnt就行 然后我们就能用线段树来维护了捏 线段树维护 无论如何产生的绝对众数唯一可能就是左右子区间cur中的一个 如果cur1==cur2 新的区间cur3=cur1 ，cnt3=cnt1+cnt2 如果不同 cur3为两段中cnt较大的一个，且cnt3为两段之差 然后查的时候只要查出来cur然后跑一遍二分查区间内个数就能确定了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct node&#123; ll num, c;&#125;;ll n, q, k;node dat[300001&lt;&lt;2];ll a[300000 + 5];ll l, r;vector&lt;ll&gt; pos[300000 + 5];node merge(node x, node y) &#123; if (x.num == y.num) return(x.num, x.c + y.c); else if (x.c &lt; y.c) return&#123; y.num,y.c - x.c &#125;; else return &#123; x.num,x.c - y.c &#125;;&#125;void pushup(ll o) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; dat[o] = merge(dat[ls], dat[rs]);&#125;void build(ll o, ll l, ll r) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (l == r) &#123; dat[o] = &#123; a[l],1 &#125;; return; &#125; ll m = l + r &gt;&gt; 1; build(ls, l, m); build(rs, m + 1, r); pushup(o);&#125;node ask(ll o, ll l, ll r, ll p, ll q) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (p&lt;= l &amp;&amp; q &gt;= r)return dat[o]; ll m = l + r &gt;&gt; 1; if (q &lt;= m)return ask(ls, l, m, p, q); if (p &gt; m)return ask(rs, m + 1, r, p, q); return merge(ask(ls, l, m, p, q), ask(rs, m + 1, r,p, q));&#125;int main() &#123; cin.sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n&gt;&gt;q; srand(time(NULL)); ll tmp; for (int i = 1; i &lt;=n; i++) &#123; cin &gt;&gt; a[i]; pos[a[i]].push_back(i); &#125; build(1, 1, n); for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; l &gt;&gt; r; ll tmp=ask(1, 1, n, l, r).num; ll ans = upper_bound(pos[tmp].begin(), pos[tmp].end(), r) - lower_bound(pos[tmp].begin(), pos[tmp].end(), l); &#125;&#125; 一般的众数 这玩意方法就可多了，这里讲一个今天把我坑麻了的莫队写法捏 我们开两个数组，cnt[]和num[]，cnt[i]是单纯统计区间里边 i 的出现次数，num[i]统计出现了 i 次的数有多少个。 然后ans就应该是令num[i]不为0的最大的i 考虑到每次更新数的时候，我们其实只会影响一个点的cnt[]和num[]，因此ans只会加1或者减1，因此可以在O(1)的时间内更新捏 那么add和del函数就能这样写了 1234567891011121314151617ll cnt[MAXN], num[MAXN];ll anss = 0;void add(ll x) &#123; ll p = dat[x]; num[cnt[p]]--; cnt[p]++; num[cnt[p]]++; anss = max(anss, cnt[p]);&#125;void del(ll x) &#123; ll p = dat[x]; num[cntt[p]]--; if (anss == cntt[p] &amp;&amp; !num[anss])anss--; --cntt[p]; num[cntt[p]]++;&#125; 本废物因为莫队学的太烂了，以至于没有想到可以用 while(l&lt;=r)del(l++) 手动清零，天天用memset()，T到了天荒地老 小朋友们千万不要学哦","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"https://pophirasawa.top/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"https://pophirasawa.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"hexo博客搭建教程(?","slug":"05杂项/hexo博客搭建","date":"2021-11-07T08:01:02.000Z","updated":"2021-11-08T14:05:53.281Z","comments":true,"path":"2021/11/07/05杂项/hexo博客搭建/","link":"","permalink":"https://pophirasawa.top/2021/11/07/05%E6%9D%82%E9%A1%B9/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"有咩有一种可能,这玩意是写来总结一下当时搭博客是有多么折磨的一件事的捏 介绍一下怎么用hexo搭建博客并部署","text":"有咩有一种可能,这玩意是写来总结一下当时搭博客是有多么折磨的一件事的捏 介绍一下怎么用hexo搭建博客并部署 首先是作为准备工作的首先 下载安装 我们需要 装一个git工具 装一个node.js 装一个hexo git工具和node.js直接去官网上下就行了捏 DownloadGit Node.js 下好了之后我们就可以用Git带的gitbush工具开始整活了 首先到你想作为blog的文件夹里右键打开gitbush，或者直接cd,输入 1npm install -g hexo 之后可以用 1hexo -v 来查版本号，看看是不是真的装好了，喜闻乐见了属于是 Github方面的工作 新建仓库 这个部分有2种 想使用Github pages功能来部署博客的，域名是 GitHub用户名+github.io 想使用cloudflare pages来部署的，域名是 自定+pages.dev 不过其实都行，反正最后可以自定义域名（ 第一种：在github上新建一个仓库，仓库名字是 你的Github用户名.github.io，然后选public 第二种对仓库名没有要求。 SSH key 这个部分是让每次push不用输账号密码了，省去了很多折磨的部分捏 首先在Gitbush里输入 12git config --global user.name &quot;yourname&quot; // 你的Github用户名git config --global user.email &quot;youremail&quot; // 你的Github邮箱 然后创建SSH 1ssh-keygen -t rsa -C &quot;youremail&quot; 然后他就会生成一个.ssh的文件夹，打开这个文件夹 找到id_rsa.pub，把里边的内容复制一哈 最后打开你的Github，找到setting里边有一个SSH keys，直接Add SSH key，把你复制的内容粘进去 用这个看看你有没有成功 1ssh -T git@github.com 他应该会说 1Hi XXX! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 其次是开始部署的其次 这里也有两种选择捏，顺带一提俺是部署到Cloudflare pages上边了 在本地使用hexo 不管怎么说，部署之前我们首先得在本地能跑吧 在你选定的文件夹里 1hexo init myblog //myblog叫啥都行 然后你会发现多了一个叫myblog的文件夹，这个就是你以后写博客，整活的根目录了 cd进这个文件夹 12hexo g //生成页面hexo s //在本地开启服务器预览 这时候你就可以在localhost:4000里看到自己的博客了，他有个预制 一般来说ctrl+c可以关掉服务，不行的话上cmd把占用了4000端口的进程kill掉也行 1hexo s -p 5000 //可以把端口设定到5000，4000端口冲突了也能这样 然后就是激动人心的部署到网站上了捏，可以 部署到Github Pages 部署到Cloudflare Pages 部署到Github Pages 打开你hexo init新建的文件夹，找到_config.yml 在里边找到deploy，改一改 123456deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master // repo里边把YourgithubName替换成你自己的 // branch里边把master换成你那个仓库主分支的名字 然后还要装一个 1npm install hexo-deployer-git --save // 有时候装了新主题报错的话，把这个重新装一下就行了捏 最后就迎来了我们激动人心的时刻 123hexo clean // 清除原来生成在public里的文件hexo g // 生成hexo d // 部署 就可以了 部署到Cloudflare Pages 首先，在本地使用hexo的那部分都要搞， 不用改deploy里边的东西 然后，我们要注册一个Cloudflare的账号，点开网页选项，创建项目 按照提示绑上你的GitHub账号，选择你作为存博客的那个仓库， 然后自己定一个你要的项目名字，他会部署到 名字.pages.dev上边 构建选项这样写就完事儿了 以后你每次就把整个文件夹push到你的Github上，他会自动构建，一个月有500次，完全够用了捏 最后是个性化以及使用方法的最后 我们已经搞的差不多了，现在是不是该写自己的第一篇博客了？ 输入 1hexo n 博客名 你会发现在source/_post文件夹内出现了一篇markdown，就可以在里边写了捏 这时，好奇的你也许会发现他开头有个类似于 123456---title: xxxdate: tag: category: --- 之类的东西，这个是标定一些你文章的属性的东西，具体来说其实还是要看你用的主题是如何规定的，自己查人主题文档去捏。 tag和category可以写多级,不过tag好像没有上下级的层次，category则是从上到下 123category:- a- b 这样就把你文章放在了a大类下的b小分类下 然后是各种个性化 换主题啊，自定义域名啊啥的，我懒得写了，自己上网查得了 找主题上https://hexo.io/themes/就行","categories":[{"name":"杂项","slug":"杂项","permalink":"https://pophirasawa.top/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://pophirasawa.top/tags/hexo/"}]},{"title":"单调队列优化多重背包","slug":"01或许是算法/单调队列优化dp","date":"2021-11-05T03:13:57.000Z","updated":"2021-11-06T08:38:15.508Z","comments":true,"path":"2021/11/05/01或许是算法/单调队列优化dp/","link":"","permalink":"https://pophirasawa.top/2021/11/05/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/","excerpt":"补题补到了个树上背包，然后发现孩子不会。这次就打算把一些该学的背包都学一手？大概。 我们知道，对于多重背包，有一个二进制拆分优化，可以在O(vlog(∑n[i]))O(vlog(\\sum{n[i]}))O(vlog(∑n[i]))级别的复杂度解决问题 然后单调队列优化可以跑到O(nv)O(nv)O(nv)","text":"补题补到了个树上背包，然后发现孩子不会。这次就打算把一些该学的背包都学一手？大概。 我们知道，对于多重背包，有一个二进制拆分优化，可以在O(vlog(∑n[i]))O(vlog(\\sum{n[i]}))O(vlog(∑n[i]))级别的复杂度解决问题 然后单调队列优化可以跑到O(nv)O(nv)O(nv) 思路 首先我们考虑一下朴素的多重背包写法： 对于当前物品i，枚举选的个数n[i]，用于更新dp数组 然后我们能够发现这样一个神必规律： dp[i]用于维护代价为i的最大价值，且当前考虑选的物品代价为v 则dp[i]只能够从dp[j]，当且仅当j mod v == i mod v 且选的个数不超过要求的点转移过来 也就是 当前在选第i个物品时 dp[j+nv]=max(dp[j+(n−1)v+w,dp[j+(n−2)v+2w,....)dp[j+nv]=max(dp[j+(n-1)v+w,dp[j+(n-2)v+2w,....) dp[j+nv]=max(dp[j+(n−1)v+w,dp[j+(n−2)v+2w,....) 改变一下形式 dp[j+nv]=max(dp[j],dp[j+v]−w,dp[j+2v]−2w,...)+nwdp[j+nv]=max(dp[j],dp[j+v]-w,dp[j+2v]-2w,...)+nw dp[j+nv]=max(dp[j],dp[j+v]−w,dp[j+2v]−2w,...)+nw 当然，因为有个数的限制，他选定的是一定区间里边的最大值，这个就给我们跑单调区间留下了伏笔捏 CODE 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include&lt;bitset&gt;#include&lt;map&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll N, V;ll f[20000 + 5];ll g[20000 + 5];ll q[20000 + 5];int main() &#123; cin &gt;&gt; N &gt;&gt; V; for (int i = 0; i &lt; N; i++) &#123; ll v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, f, sizeof(f)); for (int j = 0; j &lt; v; j++) &#123; ll l = 0, r = -1; for (int k = j; k &lt;= V; k += v) &#123; while (r &gt;= l &amp;&amp; (k - q[l]) &gt; s * v)l++;// 判断区间长度是否超过 while (r &gt;= l &amp;&amp; (g[q[r]] - (q[r] - j) / v * w) &lt; (g[k] - (k - j) / v * w))r--; q[++r] = k; f[k] = max(g[k], g[q[l]] + (k - q[l]) / v * w); &#125; &#125; &#125; ll ans = 0; for (int i = 0; i &lt;= V; i++)ans = max(f[i], ans); cout &lt;&lt; ans;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"算法/DP","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pophirasawa.top/tags/DP/"}]},{"title":"Gym103389F 地图压缩","slug":"03久远时光以前的补题记录/2021-11-5","date":"2021-11-04T16:45:04.000Z","updated":"2021-11-05T02:06:31.797Z","comments":true,"path":"2021/11/05/03久远时光以前的补题记录/2021-11-5/","link":"","permalink":"https://pophirasawa.top/2021/11/05/03%E4%B9%85%E8%BF%9C%E6%97%B6%E5%85%89%E4%BB%A5%E5%89%8D%E7%9A%84%E8%A1%A5%E9%A2%98%E8%AE%B0%E5%BD%95/2021-11-5/","excerpt":"训练的时候一看题目长的一批就根本没看，现在看看发现还是可做的啊。。 题目简述 给定一个n*n的矩阵，q次询问，每次给定一个矩形范围，问一个最小矩阵的面积，可以通过此矩阵循环覆盖给定的范围，多出的部分可以不计 例如:ababa可以通过ab循环构成","text":"训练的时候一看题目长的一批就根本没看，现在看看发现还是可做的啊。。 题目简述 给定一个n*n的矩阵，q次询问，每次给定一个矩形范围，问一个最小矩阵的面积，可以通过此矩阵循环覆盖给定的范围，多出的部分可以不计 例如:ababa可以通过ab循环构成 思路 如果一个子矩阵满足条件，把这玩意纵向扩展后肯定也可以满足条件，那么我们求可以横向循环满足的循环节和纵向的循环节长度，乘一下就行。 用hash把这玩意压成一维，在找循环节就行了。 这个就是找最长公共前后缀长度d，那么n-d就是循环节长度。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include&lt;bitset&gt;#include&lt;map&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const ll maxn = 5e5+ 5;const ll mod = 1e9 + 7;ull p1 = 131;ull p2 = 20111203;char dat[3000][3000];ull h1[3000][3000], h2[3000][3000],pp1[3000],pp2[3000];ll q;ull r[3000], c[3000];int main() &#123; ll n,q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;=n; i++)cin &gt;&gt; dat[i]+1; pp1[0] = pp2[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; pp1[i] = pp1[i - 1] * p1; pp2[i] = pp2[i - 1] * p2; &#125; for (int i = 1; i &lt;=n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; h1[i][j] = h1[i - 1][j] * p1 + dat[i][j] - &#x27;a&#x27;; h2[i][j] = h2[i][j-1] * p1 + dat[i][j] - &#x27;a&#x27;; &#125; &#125; //cin &gt;&gt; q; while (q--) &#123; ll x1, x2, y1, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; for (int i = y1; i &lt;= y2; i++)r[i] = h1[x2][i] - h1[x1 - 1][i] * pp1[x2 - x1 + 1]; for (int i = x1; i &lt;= x2; i++)c[i] = h2[i][y2] - h2[i][y1-1] * pp1[y2 - y1 + 1]; ull s1 = 0, s2 = 0; ll ans1 = -1, ans2 = -1; for (int i = 0; i+y1&lt;y2; i++) &#123; s1 = s1 * p2 + r[i+y1]; s2 = s2 + r[y2 - i]*pp2[i]; if (s1 == s2)ans1 = i; &#125; ans1 = y2 - y1 - ans1; s1 = s2 = 0; for (int i = 0; i + x1 &lt; x2; i++) &#123; s1 = s1 * p2 + c[i + x1]; s2 = s2 + c[x2 - i] * pp2[i]; if (s1 == s2)ans2 = i; &#125; ans2 = x2 - x1 - ans2; cout &lt;&lt; ans2 * ans1 &lt;&lt; &#x27;\\n&#x27;; &#125;&#125; 这里考虑一下如果d==n的时候，其实答案是n而不是n-d，把ans预设为-1可以很巧妙的解决。 结果写的时候天天犯病，对题解抄都nm能给抄歪来，hash也迷惑冲突，只能说base不能乱设了呃呃。","categories":[{"name":"补题","slug":"补题","permalink":"https://pophirasawa.top/categories/%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://pophirasawa.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"瞎掰","slug":"胡言乱语们/0X01","date":"2021-11-02T16:00:00.000Z","updated":"2022-01-03T13:41:28.552Z","comments":true,"path":"2021/11/03/胡言乱语们/0X01/","link":"","permalink":"https://pophirasawa.top/2021/11/03/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/0X01/","excerpt":"","text":"稍微回顾一下我这十几年的无聊人生经历，可以发现差不多没有任何意义。 是不是说的有点过头了（ 其实没有？ 总的来说，是有乐子，但是与故事无缘 从来没有自己真正想做什么 从来没有真正努力做过什么 因此， 付出汗与血，历经千难万难，无论结果为何，在将来回想起时， 如同某个明媚夏日、某场淅沥小雨、某道绚丽彩虹、某天傍晚意外地抬起头所看见的红色、橙色、粉色、玫瑰色、湖蓝色、群青色一般 令人莫名心跳加速的所谓美好回忆， 对我来说好像并不存在。 或许有过？ 然而最后的结局不是成功或者失败，而是被放弃、丢弃、遗忘，以至于不了了之。所谓找到的能够为之奋斗的事物最后不过是随波逐流，或者莫名自信的自我催眠。 无论如何，最后只能看着别人的故事，感受并不存在的回忆。最后再想想，如果我能这样能够如何如何。 都一样了。 想着改变却无所作为，渴望故事却不主动争取，向往美好但是固守蜗居。 那又如何 老子活得还不是好好的，哈哈。 顺便做下实验，传新的md会不会影响旧的评论啊","categories":[{"name":"胡言乱语","slug":"胡言乱语","permalink":"https://pophirasawa.top/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"}],"tags":[{"name":"胡言乱语们","slug":"胡言乱语们","permalink":"https://pophirasawa.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/"}]},{"title":"信息论","slug":"04学习/信息论","date":"2021-10-30T16:00:00.000Z","updated":"2021-11-03T04:35:51.115Z","comments":true,"path":"2021/10/31/04学习/信息论/","link":"","permalink":"https://pophirasawa.top/2021/10/31/04%E5%AD%A6%E4%B9%A0/%E4%BF%A1%E6%81%AF%E8%AE%BA/","excerpt":"呃呃呃 这玩意就是信息论课的内容了 以后更估计也就在这篇里面更了 大概","text":"呃呃呃 这玩意就是信息论课的内容了 以后更估计也就在这篇里面更了 大概 以下内容更新于2021-10-31 信息度量 离散信息度量 首先肯定是经典的各种符号约定,顺遍让我复习一哈LateX语法… 随机事件：xxx 随机变量：XXX x=ai的概率x=a_i的概率x=ai​的概率：Px(ai)P_x(a_i)Px​(ai​) 联合概率：Pxy(ai,bj)P_{xy}(a_i,b_j)Pxy​(ai​,bj​) 自信息 事件集合X中x=aix=a_ix=ai​的自信息 Ix(ai)=−logPx(ai)I_x(a_i)=-logP_x(a_i)Ix​(ai​)=−logPx​(ai​) I(x)=−logp(x)I(x)=-logp(x)I(x)=−logp(x) 底数可变 log2xlog_2xlog2​x：比特 lnxlnxlnx：奈特 log10xlog_{10}xlog10​x：哈特 自信息的含义即 事件发生前的不确定性 事件发生后事件包含的信息量 联合自信息 即一些事件看作一个联合事件后计算自信息，概率为联合概率 IXY(ai,bj)=−logPXY(ai,bj)I_{XY}(a_i,b_j)=-logP_{XY}(a_i,b_j)IXY​(ai​,bj​)=−logPXY​(ai​,bj​) I(xy)=−logp(xy)I(xy)=-logp(xy)I(xy)=−logp(xy) xyxyxy视为一联合事件 条件自信息 即给定一些事件后，发生其他事件的自信息 Ix∣y(ai,bj)=−logPX∣Y(ai,bj)I_{x|y}(a_i,b_j)=-logP_{X|Y}(a_i,b_j)Ix∣y​(ai​,bj​)=−logPX∣Y​(ai​,bj​) I(x∣y)=−logp(x∣y)I(x|y)=-logp(x|y)I(x∣y)=−logp(x∣y) 因此有： I(xy)=I(x)+I(y∣x)=I(y)+I(x∣y)I(xy)=I(x)+I(y|x)=I(y)+I(x|y)I(xy)=I(x)+I(y∣x)=I(y)+I(x∣y) 综上 自信息量表示一个/多个事件发生带给我们信息量的大小 表示了确定一个/多个事件是否发生，所需要的信息量的大小 log2log_2log2​情况下表示了表示出事件信息量所需要的二进制位的个数 互信息 反映了两个事件之间的统计关联程度 通信系统中，意义是输出端接受到某信息y后获得关于输入端某信息x的信息量 Ix;y(ai;bj)=logPX/Y(ai∣bj)PX(ai)I_{x;y}(a_i;b_j)=log\\frac{P_{X/Y}(a_i|b_j)}{P_X(a_i)}Ix;y​(ai​;bj​)=logPX​(ai​)PX/Y​(ai​∣bj​)​ I(x;y)=I(x)−I(x∣y)I(x;y)=I(x)-I(x|y)I(x;y)=I(x)−I(x∣y) //xxx本身的不确定性减去由yyy确定的xxx的不确定性 I(x;y)=I(y;x)I(x;y)=I(y;x)I(x;y)=I(y;x) 信息熵 离散信源X的熵定义位自信息的平均值，记为H(X) H(X)=E[I(x)]H(X)=E[I(x)]H(X)=E[I(x)] 单位：比特/符号 表现一个信源的平均不确定性/平均信息量、H(x)H(x)H(x)大的随机性大、输出后解除信息不确定行需要的信息量。 条件熵 联合集XYXYXY上，条件自信息I(y∣x)I(y|x)I(y∣x)均值 H(Y∣X)=E[I(y∣x)]=∑xp(x)H(Y∣X=x)H(Y|X)=E[I(y|x)]=\\sum_{x}{p(x)H(Y|X=x)}H(Y∣X)=E[I(y∣x)]=∑x​p(x)H(Y∣X=x) 联合熵 联合集XYXYXY上，条件自信息I(xy)I(xy)I(xy)均值 H(XY)=E[U(xy)]=−∑x∑yp(xy)logp(xy)H(XY)=E[U(xy)]=-\\sum_x\\sum_yp(xy)logp(xy)H(XY)=E[U(xy)]=−∑x​∑y​p(xy)logp(xy) 相对熵——信息散度 没懂。 不等式：1−1x≤lnx≤x−11-\\frac{1}{x}\\leq lnx \\leq x-11−x1​≤lnx≤x−1 熵的不增原理——条件熵不大于信息熵 H(Y∣X)≤H(Y)H(Y|X)\\leq H(Y)H(Y∣X)≤H(Y) 信息熵基本性质 对称性 非负性 确定性：集合中任意事件概率为1时，熵为0 扩展性：小概率事件对熵影响很小可以忽略 可加性：H(XY)=H(X)+H(Y∣X)H(XY)=H(X)+H(Y|X)H(XY)=H(X)+H(Y∣X) 熵的链原则：H(X1X2..XN)=H(X1)+H(X2∣X1)+...H(XN∣X1..XN−1)H(X_1X_2..X_N)=H(X_1)+H(X_2|X_1)+...H(X_N|X_1..X_{N-1})H(X1​X2​..XN​)=H(X1​)+H(X2​∣X1​)+...H(XN​∣X1​..XN−1​) 极值性：集合中事件等概率发生时熵达到最大 平均互信息 集合Y与事件x=ai间的互信息集合Y与事件x=a_i间的互信息集合Y与事件x=ai​间的互信息 I(x;Y)=∑xp(x)I(x;Y)I(x;Y)=\\sum_xp(x)I(x;Y)I(x;Y)=∑x​p(x)I(x;Y) =∑x,yp(x)p(y∣x)logp(y∣x)p(y)=\\sum_{x,y}p(x)p(y|x)log\\frac{p(y|x)}{p(y)}=∑x,y​p(x)p(y∣x)logp(y)p(y∣x)​ 因此 集合X、Y间平均互信息集合X、Y间平均互信息集合X、Y间平均互信息 I(X;Y)=∑xp(x)I(x;Y)I(X;Y)=\\sum_xp(x)I(x;Y)I(X;Y)=∑x​p(x)I(x;Y) 含义 知道集合YYY后，平均Y中一个事件消除掉的关于集合XXX中一个事件的不确定性 集合YYY中一个事件平均能提供出的关于集合XXX中一事件的信息量 两个集合关系密切程度 平均互信息与熵 I(X;Y)=H(X)−H(X∣Y)=H(Y)−H(Y∣X)=H(X)+H(Y)−H(XY)I(X;Y)=H(X)-H(X|Y)=H(Y)-H(Y|X)=H(X)+H(Y)-H(XY)I(X;Y)=H(X)−H(X∣Y)=H(Y)−H(Y∣X)=H(X)+H(Y)−H(XY) 性质 非负性 互易性 凸函数性： 为p(x)p(x)p(x)上凸函数","categories":[{"name":"课内","slug":"课内","permalink":"https://pophirasawa.top/categories/%E8%AF%BE%E5%86%85/"}],"tags":[{"name":"信息论","slug":"信息论","permalink":"https://pophirasawa.top/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"}]},{"title":"通信原理","slug":"04学习/通信原理","date":"2021-10-30T16:00:00.000Z","updated":"2021-11-03T04:35:55.156Z","comments":true,"path":"2021/10/31/04学习/通信原理/","link":"","permalink":"https://pophirasawa.top/2021/10/31/04%E5%AD%A6%E4%B9%A0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/","excerpt":"","text":"目前啥都没有","categories":[{"name":"课内","slug":"课内","permalink":"https://pophirasawa.top/categories/%E8%AF%BE%E5%86%85/"}],"tags":[{"name":"通信原理","slug":"通信原理","permalink":"https://pophirasawa.top/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"}]},{"title":"EXGCD","slug":"01或许是算法/类&拓展欧几里得","date":"2021-10-29T16:00:00.000Z","updated":"2021-11-01T16:34:16.267Z","comments":true,"path":"2021/10/30/01或许是算法/类&拓展欧几里得/","link":"","permalink":"https://pophirasawa.top/2021/10/30/01%E6%88%96%E8%AE%B8%E6%98%AF%E7%AE%97%E6%B3%95/%E7%B1%BB&%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"EXGCD 用于解形如ax+by=gcd（a，b）方程的通解","text":"EXGCD 用于解形如ax+by=gcd（a，b）方程的通解 12345678910111213void exgcd(int &amp;x,int &amp;y,int a,int b)&#123; if(!b) &#123; x=1; y=0; return; &#125; exgcd(x,y,b,a%b); int t=x; x=y; y=t-a/b*y;&#125; 也可以解出ax+by=c gcd（a，b）|c的解 上方参数还是gcd（a，b） 解出后x2=x*c/gcd（a，b） y2=y*c/gcd（a，b） 通解为： {(x, y) | x = x2 + k * b / gcd(a, b)， y = y2 - k * a / gcd(a, b), k ∈ z} 特别的 gcd（a，b）等于1时 相当于求ax=1（modb） 为a在b下的逆元（不用b是质数） 解出x后用 x=（x%b+b）%b求出在0-b范围内的x即为逆元 类欧几里得 当我们要计算形如 ∑i=0n⌊ai+bc⌋ \\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor i=0∑n​⌊cai+b​⌋ 且a，b&gt;=0,c&gt;0时 可以使用类欧算法。 首先有以下公式 ⌈ab⌉=⌊a+b−1b⌋\\lceil \\frac{a}{b}\\rceil = \\lfloor \\frac{a+b-1}{b}\\rfloor ⌈ba​⌉=⌊ba+b−1​⌋ ⌊ab⌋=⌈a−b+1b⌉\\lfloor\\frac{a}{b}\\rfloor = \\lceil \\frac{a-b+1}{b}\\rceil ⌊ba​⌋=⌈ba−b+1​⌉ 挺容易推的：关于1式，如果 a % b != 0,那么右边就会比左边大1，2式原理相同。 然后开始推（？ 我们令 F(a,b,c,n)=∑i=0n⌊ai+bc⌋F(a,b,c,n)=\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor F(a,b,c,n)=i=0∑n​⌊cai+b​⌋ a≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n(⌊a%c×i+bc⌋+⌊ac⌋i)=∑i=0n⌊a%c×i+bc⌋+⌊ac⌋n×(n+1)2{a}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n(\\lfloor \\frac{a\\%c\\times i+b}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor i)=\\sum_{i=0}^n\\lfloor \\frac{a\\%c\\times i+b}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} a≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​(⌊ca%c×i+b​⌋+⌊ca​⌋i)=i=0∑n​⌊ca%c×i+b​⌋+⌊ca​⌋2n×(n+1)​ b≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n⌊ai+b%cc⌋+⌊bc⌋(n+1){b}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n\\lfloor \\frac{a i+b\\% c}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor(n+1) b≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​⌊cai+b%c​⌋+⌊cb​⌋(n+1) 因此 a≥c∣∣b≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n⌊(a%c)i+b%cc⌋+⌊bc⌋(n+1)+⌊ac⌋n×(n+1)2{a}\\geq{c}||{b}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n\\lfloor \\frac{(a\\%c) i+b\\% c}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor(n+1)+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} a≥c∣∣b≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​⌊c(a%c)i+b%c​⌋+⌊cb​⌋(n+1)+⌊ca​⌋2n×(n+1)​ ⇒F(a,b,c,n)=F(a%c,b%c,c,n)++⌊bc⌋(n+1)+⌊ac⌋n×(n+1)2\\Rightarrow F(a,b,c,n) = F(a\\%c,b\\%c,c,n)++\\lfloor\\frac{b}{c}\\rfloor(n+1)+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} ⇒F(a,b,c,n)=F(a%c,b%c,c,n)++⌊cb​⌋(n+1)+⌊ca​⌋2n×(n+1)​ 之后只要解决a&lt;c&amp;&amp;b&lt;ca \\lt c \\&amp;\\&amp; b\\lt ca&lt;c&amp;&amp;b&lt;c的情况就好了（？ 由 ∑i=0n⌊ai+bc⌋=∑i=0n∑j=1⌊ai+bc⌋1=∑i=0n∑j=1⌊an+bc⌋[j≤⌊ai+bc⌋]\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor =\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor \\frac{ai+b}{c}\\rfloor}1 =\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[{j\\leq \\lfloor \\frac{ai+b}{c}\\rfloor}] i=0∑n​⌊cai+b​⌋=i=0∑n​j=1∑⌊cai+b​⌋​1=i=0∑n​j=1∑⌊can+b​⌋​[j≤⌊cai+b​⌋] 交换求和顺序（ ⇒∑j=1⌊an+bc⌋∑i=0n[j≤⌊ai+bc⌋]\\Rightarrow \\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[{j\\leq \\lfloor \\frac{ai+b}{c}\\rfloor}] ⇒j=1∑⌊can+b​⌋​i=0∑n​[j≤⌊cai+b​⌋] 又有 ⌊ab⌋≥c⇔a≥bc\\lfloor \\frac{a}{b} \\rfloor \\geq c \\Leftrightarrow a\\geq bc ⌊ba​⌋≥c⇔a≥bc ⌈ab⌉≤c⇔a≤bc\\lceil \\frac{a}{b} \\rceil \\leq c \\Leftrightarrow a\\leq bc ⌈ba​⌉≤c⇔a≤bc 因此 =∑j=1⌊an+bc⌋∑i=0n[jc≤ai+b]=∑j=1⌊an+bc⌋∑i=0n[⌈jc−ba⌉≤i]=∑j=1⌊an+bc⌋[n+1−⌈jc−ba⌉]=\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[jc\\leq {ai+b}] =\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[\\lceil \\frac{jc-b}{a} \\rceil \\leq i] =\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[n+1-\\lceil \\frac{jc-b}{a} \\rceil] =j=1∑⌊can+b​⌋​i=0∑n​[jc≤ai+b]=j=1∑⌊can+b​⌋​i=0∑n​[⌈ajc−b​⌉≤i]=j=1∑⌊can+b​⌋​[n+1−⌈ajc−b​⌉] =∑j=1⌊an+bc⌋[n+1−⌊jc−b+a−1a⌋]=\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[n+1-\\lfloor \\frac{jc-b+a-1}{a} \\rfloor] =j=1∑⌊can+b​⌋​[n+1−⌊ajc−b+a−1​⌋] =n⌊an+bc⌋−∑j=1⌊an+bc⌋[⌊jc−b+a−1a⌋−1]=n⌊an+bc⌋−∑j=0⌊an+bc⌋−1[⌊(j+1)c−b−1a⌋]=n\\lfloor \\frac{an+b}{c}\\rfloor-\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[\\lfloor \\frac{jc-b+a-1}{a} \\rfloor-1] =n\\lfloor \\frac{an+b}{c}\\rfloor-\\sum_{j=0}^{\\lfloor \\frac{an+b}{c}\\rfloor-1}[\\lfloor \\frac{(j+1)c-b-1}{a} \\rfloor] =n⌊can+b​⌋−j=1∑⌊can+b​⌋​[⌊ajc−b+a−1​⌋−1]=n⌊can+b​⌋−j=0∑⌊can+b​⌋−1​[⌊a(j+1)c−b−1​⌋] 因此我们有a,b&lt;ca,b\\lt ca,b&lt;c时 F(a,b,c,n)=n⌊an+bc⌋−F(c,−1−b+c,a,⌊an+bc⌋−1)F(a,b,c,n)=n\\lfloor \\frac{an+b}{c}\\rfloor-F(c,-1-b+c,a,\\lfloor \\frac{an+b}{c}\\rfloor-1) F(a,b,c,n)=n⌊can+b​⌋−F(c,−1−b+c,a,⌊can+b​⌋−1) 然后就 可以递归了 终止条件a=0 以下代码 123456ll exgcd(ll a, ll b, ll c, ll n)&#123; if(a==0) return (n+1)*(b/c); if(a&gt;=c||b&gt;=c) return exgcd(a%c, b%c, c, n) + floor(a/c)*n*(n+1)/2 + floor(b/c)*(n+1); ll temp = (a*n+b)/c; return n*temp - exgcd(c, c-b-1, a, temp-1);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Hello?","slug":"胡言乱语们/0X00","date":"2021-10-28T16:00:00.000Z","updated":"2022-01-11T16:52:04.174Z","comments":true,"path":"2021/10/29/胡言乱语们/0X00/","link":"","permalink":"https://pophirasawa.top/2021/10/29/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/0X00/","excerpt":"","text":"这里以后也许会有一些胡言乱语…","categories":[{"name":"胡言乱语","slug":"胡言乱语","permalink":"https://pophirasawa.top/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"}],"tags":[{"name":"胡言乱语们","slug":"胡言乱语们","permalink":"https://pophirasawa.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/"}]}],"categories":[{"name":"DRL","slug":"DRL","permalink":"https://pophirasawa.top/categories/DRL/"},{"name":"算法","slug":"算法","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"c++","slug":"c","permalink":"https://pophirasawa.top/categories/c/"},{"name":"课外","slug":"课外","permalink":"https://pophirasawa.top/categories/%E8%AF%BE%E5%A4%96/"},{"name":"JAVA","slug":"JAVA","permalink":"https://pophirasawa.top/categories/JAVA/"},{"name":"字符串","slug":"算法/字符串","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"补题","slug":"补题","permalink":"https://pophirasawa.top/categories/%E8%A1%A5%E9%A2%98/"},{"name":"组合数学","slug":"组合数学","permalink":"https://pophirasawa.top/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"杂项","slug":"杂项","permalink":"https://pophirasawa.top/categories/%E6%9D%82%E9%A1%B9/"},{"name":"DP","slug":"算法/DP","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/DP/"},{"name":"胡言乱语","slug":"胡言乱语","permalink":"https://pophirasawa.top/categories/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"},{"name":"课内","slug":"课内","permalink":"https://pophirasawa.top/categories/%E8%AF%BE%E5%86%85/"},{"name":"数学","slug":"算法/数学","permalink":"https://pophirasawa.top/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"RL","slug":"RL","permalink":"https://pophirasawa.top/tags/RL/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"语言","slug":"语言","permalink":"https://pophirasawa.top/tags/%E8%AF%AD%E8%A8%80/"},{"name":"自动机","slug":"自动机","permalink":"https://pophirasawa.top/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"回文","slug":"回文","permalink":"https://pophirasawa.top/tags/%E5%9B%9E%E6%96%87/"},{"name":"字符串","slug":"字符串","permalink":"https://pophirasawa.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数学","slug":"数学","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/tags/SAM/"},{"name":"莫队","slug":"莫队","permalink":"https://pophirasawa.top/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"https://pophirasawa.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"hexo","slug":"hexo","permalink":"https://pophirasawa.top/tags/hexo/"},{"name":"DP","slug":"DP","permalink":"https://pophirasawa.top/tags/DP/"},{"name":"胡言乱语们","slug":"胡言乱语们","permalink":"https://pophirasawa.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E4%BB%AC/"},{"name":"信息论","slug":"信息论","permalink":"https://pophirasawa.top/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"},{"name":"通信原理","slug":"通信原理","permalink":"https://pophirasawa.top/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"数论","slug":"数论","permalink":"https://pophirasawa.top/tags/%E6%95%B0%E8%AE%BA/"}]}