{"meta":{"title":"PopHirasawa's wiki","subtitle":"循此苦旅，直抵群星。","description":"","author":"PopHirasawa","url":"https://pophirasawa.top/wiki","root":"/wiki/"},"pages":[{"title":"Categories","date":"2022-01-02T00:39:26.087Z","updated":"2022-01-02T00:24:35.060Z","comments":true,"path":"categories/index.html","permalink":"https://pophirasawa.top/wiki/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2022-01-02T03:21:59.241Z","updated":"2022-01-02T03:21:59.241Z","comments":true,"path":"about/index.html","permalink":"https://pophirasawa.top/wiki/about/index.html","excerpt":"","text":"这个是wiki分页 搞得也太麻烦了 使用文件夹进行分类 装了一个hexo-directory-category"},{"title":"Tags","date":"2022-01-02T00:24:35.063Z","updated":"2022-01-02T00:24:35.063Z","comments":true,"path":"tags/index.html","permalink":"https://pophirasawa.top/wiki/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"鸽巢原理","slug":"01学习/组合数学/a","date":"2022-01-09T17:10:00.000Z","updated":"2022-01-09T18:00:44.623Z","comments":true,"path":"wiki/01学习/组合数学/a/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/01%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/a/","excerpt":"内容 鸽巢原理及其一些推论，包括但不限于 简单形式 中国剩余定理 加强形式 Ramesy定理 呃呃","text":"内容 鸽巢原理及其一些推论，包括但不限于 简单形式 中国剩余定理 加强形式 Ramesy定理 呃呃 简单形式 n+1个物品放入n个盒子中，至少存在一个盒子中存在多个物品 可以抽象表示为: 令X，Y为两有限集，令f为一个从X到Y的函数 若X的元素大于Y的元素，则f不是一对一的 若X和Y有相同个数的元素，且f是映上的，则f是一对一的 若X和Y有相同个数的元素，且f是一对一的，则f是映上的 然后就可以发展出一些应用了 推论：中国剩余定理 令m和n为互素的正整数，有正整数a、b，且a不大于m-1，b不大于n-1。则存在x，x mod m = a，x mod n = b。 证明：先得出在a，a+m，a+2m，…(n-1)m+a中mod n没有相同的余数。因此n个数中0到n-1每个数都作为余数出现。那对与b也存在对应的p令pm+a mod n = b","categories":[{"name":"01学习","slug":"01学习","permalink":"https://pophirasawa.top/wiki/categories/01%E5%AD%A6%E4%B9%A0/"},{"name":"组合数学","slug":"01学习/组合数学","permalink":"https://pophirasawa.top/wiki/categories/01%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"0X00","slug":"Homepage","date":"2022-01-01T16:00:00.000Z","updated":"2022-01-02T03:05:53.684Z","comments":true,"path":"wiki/Homepage/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/Homepage/","excerpt":"","text":"Hello！ 这里应该是wiki吧… 也是一个在hexo里边塞两种不同主题的尝试 好像貌似大概可能是成功了 所有这里放的应该是一些应该放到的wiki里边的东西 芜湖~","categories":[],"tags":[]},{"title":"后缀自动机","slug":"00算法/字符串/sam","date":"2021-11-19T18:08:36.000Z","updated":"2022-01-03T13:35:02.386Z","comments":true,"path":"wiki/00算法/字符串/sam/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/00%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/sam/","excerpt":"这玩意就是SAM的原理以及基本板子了，大概，说不定再来一点套路总结吧 总的来说，这玩意拖的也太久了，一直说要学，然后狂摸不止，我 有罪！ 欸嘿","text":"这玩意就是SAM的原理以及基本板子了，大概，说不定再来一点套路总结吧 总的来说，这玩意拖的也太久了，一直说要学，然后狂摸不止，我 有罪！ 欸嘿 介绍 首先后缀自动机 可以包括给定字符串的所有子串 O(n) 是自动机 一些定义 endpos 字符串s的一个子串t，endpos(t)为s中t的所有结束位置构成的集合 SAM是一个最小的DFA 有向无环图 节点是状态，边是转移 转移是一些字母 从源点出发到终止状态所有转移连起来的字符串t是字符串s的一个后缀 SAM的节点最小 那么如果endpos(t1)=endpos(t2)，那么他们就在一个等价类中 一堆引理 两个非空子串u，w (|u|&lt;=|w|) endpos相同，只有u在s中每次出现都是以w的后缀出现的 那么就可以推出来： 考虑u，w (|u|&lt;=|w|) 只有2种可能 endpos(u),endpos(w)不相交 endpos(w)是endpos(u)的子集 一个endpos等价类里边，所有子串长度不同，而且差值为1，正好覆盖区间 然后就有我们的后缀link 对于一个不是源点的状态v，然后考虑这个endpos等价类中最长的字符串w，其他的就是w后缀了捏 然后我们有 w开始，有一个连续区间长度的后缀也都是这个等价类里边的玩意，定义最长的一个不是等价类里边的后缀为t，把v的后缀link到t上 显然最后是link到源点的 最后这玩意就构成了一个树 然后我们就可以开始算法本身了捏 算法实现 哥们看不懂捏 首先说重点 后缀link树和后缀自动机共同相同的节点，不同的只是转移的边不同 大概步骤 首先，这个是在线算法，我们每次往自动机里加入一个字符，然后维护SAM 首先定义初始状态 这个点编号0，len=0，fa=0 然后我们就能挨个加入字符c了 有以下流程 首先我们加入了一个新字符，那么新串对应的的endpos是新的长度，以前不存在，因此我们新建一个状态np，之前整个旧串对应的状态记为p，很显然len(q)=len§+1 然后对于新加入的字符c，我们进行以下操作 如果p没有一个字符c的出边(这里是自动机的边)，就在link树上到他的父节点，也就是后缀link的点，一直循环直到p到达初始状态的节点或者有一个字符c的出边 这个操作其实是压缩遍历旧串的所有后缀x，然后看是否存在一个x+c在旧串种就存在了，因为引理中已经提到，每个状态link到的节点都是当前状态的后缀，所有我们从p上来肯定是旧串的后缀了捏 途中我们把经过每个没有c出边的p都连一个c到np 然后我们就有3种情况 Case 1 p到初始状态都没有c的出边 np状态直接link到初始状态 Case 2 找到了一个p，有c的出边，到达一个新状态q，且len( q )=len( p )+1 首先我们知道p是旧串后缀，q是p的字符串+c，因此q是新串的后缀，那么我们理所当然把np link 到q上就行了 Case 3 和case2差不多，但是找到的p出边到达的q没有len( q )=len( p )+1 或者说，len( q )&gt;len( q )+1 这时候我们要把q拆成两个点，是新串后缀的和不是的，然后link就行 具体来说，定义一个新点nq，len=len§+1,出边转移和q相同，link 到p上，然后np和q都link到nq上 最后稍微更新下转移边，p往上走，把所有p link 到q的转移 link 到nq上就行了 最后稍微提一下如何计算每个状态的endpos大小 设想一下，我们每次加入一个字符c，肯定会出现一个新的endpos，而且他能够对往上走到源点经过的所有节点都产生影响，也就是说我们使用一个数组f[i]来统计endpos，加入新字符时让f[np]=1,最后跑一下dfs，f[i]=f[i]+sum(f[i所有的儿子]) 即可捏 或者把sam的点按len排序(可以用桶排) 从大到小更新 **f[sam[i].fa]+=f[i]**也行 code 先贴一手毛的板子 1234567891011121314151617181920212223242526struct NODE&#123; int ch[26]; int len,fa; NODE()&#123;memset(ch,0,sizeof(ch));len=0;&#125;&#125;sam[MAXN&lt;&lt;1];int lst=1,tot=1;void add(int c)&#123; int p=lst;int np=lst=++tot; sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa)sam[p].ch[c]=np; if(!p)sam[np].fa=1;//以上为case 1 else &#123; int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1)sam[np].fa=q;//以上为case 2 else &#123; int nq=++tot;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa)sam[p].ch[c]=nq;//以上为case 3 &#125; &#125;&#125; 暂时先写这么多，乏了，早上写一手题以及用法吧","categories":[{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"00算法/字符串","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/wiki/tags/SAM/"}]},{"title":"维护区间众数","slug":"00算法/数据结构/维护区间众数","date":"2021-11-10T09:32:12.000Z","updated":"2022-01-03T13:34:45.948Z","comments":true,"path":"wiki/00算法/数据结构/维护区间众数/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/00%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/","excerpt":"这玩意好像方法挺多的，然后今天被一个阴间东西坑了，来说一哈 其实就是给一个数列，然后给一堆询问，问你区间众数是多少吧","text":"这玩意好像方法挺多的，然后今天被一个阴间东西坑了，来说一哈 其实就是给一个数列，然后给一堆询问，问你区间众数是多少吧 首先先把我之前的复制一手啊 绝对众数问题 就是出现个数超过n/2的众数 这个我们可以用一个摩尔投票的方法来写捏 摩尔投票 首先考虑一个序列，里面两两取数，如果一样就留下，不一样就两个数都消掉，那么最后留下的数肯定就是数量超过n/2的数 实现的话，用两个变量cur和cnt，如果当前的数和cur不同且cnt==0 cur变为当前数，否则cnt– 如果相同 cnt++ 最后cur就是唯一有可能是绝对众数的数，然后跑一遍确认即可 123456789101112ll dat[maxn];ll majorityElement()&#123; ll cnt=1,cur=dat[0]; for(int i=1;i&lt;n;i++)&#123; if(dat[i]!=cnt)cnt--; else cnt++; if(cnt&lt;0)&#123; cut=dat[i]; cnt=0; &#125; &#125;&#125; 如果是n/3以至于n/k 其实就是设置多组cur和cnt就行 然后我们就能用线段树来维护了捏 线段树维护 无论如何产生的绝对众数唯一可能就是左右子区间cur中的一个 如果cur1==cur2 新的区间cur3=cur1 ，cnt3=cnt1+cnt2 如果不同 cur3为两段中cnt较大的一个，且cnt3为两段之差 然后查的时候只要查出来cur然后跑一遍二分查区间内个数就能确定了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct node&#123; ll num, c;&#125;;ll n, q, k;node dat[300001&lt;&lt;2];ll a[300000 + 5];ll l, r;vector&lt;ll&gt; pos[300000 + 5];node merge(node x, node y) &#123; if (x.num == y.num) return(x.num, x.c + y.c); else if (x.c &lt; y.c) return&#123; y.num,y.c - x.c &#125;; else return &#123; x.num,x.c - y.c &#125;;&#125;void pushup(ll o) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; dat[o] = merge(dat[ls], dat[rs]);&#125;void build(ll o, ll l, ll r) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (l == r) &#123; dat[o] = &#123; a[l],1 &#125;; return; &#125; ll m = l + r &gt;&gt; 1; build(ls, l, m); build(rs, m + 1, r); pushup(o);&#125;node ask(ll o, ll l, ll r, ll p, ll q) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (p&lt;= l &amp;&amp; q &gt;= r)return dat[o]; ll m = l + r &gt;&gt; 1; if (q &lt;= m)return ask(ls, l, m, p, q); if (p &gt; m)return ask(rs, m + 1, r, p, q); return merge(ask(ls, l, m, p, q), ask(rs, m + 1, r,p, q));&#125;int main() &#123; cin.sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n&gt;&gt;q; srand(time(NULL)); ll tmp; for (int i = 1; i &lt;=n; i++) &#123; cin &gt;&gt; a[i]; pos[a[i]].push_back(i); &#125; build(1, 1, n); for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; l &gt;&gt; r; ll tmp=ask(1, 1, n, l, r).num; ll ans = upper_bound(pos[tmp].begin(), pos[tmp].end(), r) - lower_bound(pos[tmp].begin(), pos[tmp].end(), l); &#125;&#125; 一般的众数 这玩意方法就可多了，这里讲一个今天把我坑麻了的莫队写法捏 我们开两个数组，cnt[]和num[]，cnt[i]是单纯统计区间里边 i 的出现次数，num[i]统计出现了 i 次的数有多少个。 然后ans就应该是令num[i]不为0的最大的i 考虑到每次更新数的时候，我们其实只会影响一个点的cnt[]和num[]，因此ans只会加1或者减1，因此可以在O(1)的时间内更新捏 那么add和del函数就能这样写了 1234567891011121314151617ll cnt[MAXN], num[MAXN];ll anss = 0;void add(ll x) &#123; ll p = dat[x]; num[cnt[p]]--; cnt[p]++; num[cnt[p]]++; anss = max(anss, cnt[p]);&#125;void del(ll x) &#123; ll p = dat[x]; num[cntt[p]]--; if (anss == cntt[p] &amp;&amp; !num[anss])anss--; --cntt[p]; num[cntt[p]]++;&#125; 本废物因为莫队学的太烂了，以至于没有想到可以用 while(l&lt;=r)del(l++) 手动清零，天天用memset()，T到了天荒地老 小朋友们千万不要学哦","categories":[{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"00算法/数据结构","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"https://pophirasawa.top/wiki/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"https://pophirasawa.top/wiki/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"单调队列优化多重背包","slug":"00算法/DP/单调队列优化dp","date":"2021-11-05T03:13:57.000Z","updated":"2022-01-02T03:20:37.163Z","comments":true,"path":"wiki/00算法/DP/单调队列优化dp/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/00%E7%AE%97%E6%B3%95/DP/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/","excerpt":"补题补到了个树上背包，然后发现孩子不会。这次就打算把一些该学的背包都学一手？大概。 我们知道，对于多重背包，有一个二进制拆分优化，可以在O(vlog(∑n[i]))O(vlog(\\sum{n[i]}))O(vlog(∑n[i]))级别的复杂度解决问题 然后单调队列优化可以跑到O(nv)O(nv)O(nv)","text":"补题补到了个树上背包，然后发现孩子不会。这次就打算把一些该学的背包都学一手？大概。 我们知道，对于多重背包，有一个二进制拆分优化，可以在O(vlog(∑n[i]))O(vlog(\\sum{n[i]}))O(vlog(∑n[i]))级别的复杂度解决问题 然后单调队列优化可以跑到O(nv)O(nv)O(nv) 思路 首先我们考虑一下朴素的多重背包写法： 对于当前物品i，枚举选的个数n[i]，用于更新dp数组 然后我们能够发现这样一个神必规律： dp[i]用于维护代价为i的最大价值，且当前考虑选的物品代价为v 则dp[i]只能够从dp[j]，当且仅当j mod v == i mod v 且选的个数不超过要求的点转移过来 也就是 当前在选第i个物品时 dp[j+nv]=max(dp[j+(n−1)v+w,dp[j+(n−2)v+2w,....)dp[j+nv]=max(dp[j+(n-1)v+w,dp[j+(n-2)v+2w,....) dp[j+nv]=max(dp[j+(n−1)v+w,dp[j+(n−2)v+2w,....) 改变一下形式 dp[j+nv]=max(dp[j],dp[j+v]−w,dp[j+2v]−2w,...)+nwdp[j+nv]=max(dp[j],dp[j+v]-w,dp[j+2v]-2w,...)+nw dp[j+nv]=max(dp[j],dp[j+v]−w,dp[j+2v]−2w,...)+nw 当然，因为有个数的限制，他选定的是一定区间里边的最大值，这个就给我们跑单调区间留下了伏笔捏 CODE 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include&lt;bitset&gt;#include&lt;map&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll N, V;ll f[20000 + 5];ll g[20000 + 5];ll q[20000 + 5];int main() &#123; cin &gt;&gt; N &gt;&gt; V; for (int i = 0; i &lt; N; i++) &#123; ll v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, f, sizeof(f)); for (int j = 0; j &lt; v; j++) &#123; ll l = 0, r = -1; for (int k = j; k &lt;= V; k += v) &#123; while (r &gt;= l &amp;&amp; (k - q[l]) &gt; s * v)l++;// 判断区间长度是否超过 while (r &gt;= l &amp;&amp; (g[q[r]] - (q[r] - j) / v * w) &lt; (g[k] - (k - j) / v * w))r--; q[++r] = k; f[k] = max(g[k], g[q[l]] + (k - q[l]) / v * w); &#125; &#125; &#125; ll ans = 0; for (int i = 0; i &lt;= V; i++)ans = max(f[i], ans); cout &lt;&lt; ans;&#125;","categories":[{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"00算法/DP","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pophirasawa.top/wiki/tags/DP/"}]},{"title":"EXGCD","slug":"00算法/数学/类&拓展欧几里得","date":"2021-10-29T16:00:00.000Z","updated":"2022-01-03T13:34:54.789Z","comments":true,"path":"wiki/00算法/数学/类&拓展欧几里得/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/00%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E7%B1%BB&%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"EXGCD 用于解形如ax+by=gcd（a，b）方程的通解","text":"EXGCD 用于解形如ax+by=gcd（a，b）方程的通解 12345678910111213void exgcd(int &amp;x,int &amp;y,int a,int b)&#123; if(!b) &#123; x=1; y=0; return; &#125; exgcd(x,y,b,a%b); int t=x; x=y; y=t-a/b*y;&#125; 也可以解出ax+by=c gcd（a，b）|c的解 上方参数还是gcd（a，b） 解出后x2=x*c/gcd（a，b） y2=y*c/gcd（a，b） 通解为： {(x, y) | x = x2 + k * b / gcd(a, b)， y = y2 - k * a / gcd(a, b), k ∈ z} 特别的 gcd（a，b）等于1时 相当于求ax=1（modb） 为a在b下的逆元（不用b是质数） 解出x后用 x=（x%b+b）%b求出在0-b范围内的x即为逆元 类欧几里得 当我们要计算形如 ∑i=0n⌊ai+bc⌋ \\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor i=0∑n​⌊cai+b​⌋ 且a，b&gt;=0,c&gt;0时 可以使用类欧算法。 首先有以下公式 ⌈ab⌉=⌊a+b−1b⌋\\lceil \\frac{a}{b}\\rceil = \\lfloor \\frac{a+b-1}{b}\\rfloor ⌈ba​⌉=⌊ba+b−1​⌋ ⌊ab⌋=⌈a−b+1b⌉\\lfloor\\frac{a}{b}\\rfloor = \\lceil \\frac{a-b+1}{b}\\rceil ⌊ba​⌋=⌈ba−b+1​⌉ 挺容易推的：关于1式，如果 a % b != 0,那么右边就会比左边大1，2式原理相同。 然后开始推（？ 我们令 F(a,b,c,n)=∑i=0n⌊ai+bc⌋F(a,b,c,n)=\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor F(a,b,c,n)=i=0∑n​⌊cai+b​⌋ a≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n(⌊a%c×i+bc⌋+⌊ac⌋i)=∑i=0n⌊a%c×i+bc⌋+⌊ac⌋n×(n+1)2{a}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n(\\lfloor \\frac{a\\%c\\times i+b}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor i)=\\sum_{i=0}^n\\lfloor \\frac{a\\%c\\times i+b}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} a≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​(⌊ca%c×i+b​⌋+⌊ca​⌋i)=i=0∑n​⌊ca%c×i+b​⌋+⌊ca​⌋2n×(n+1)​ b≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n⌊ai+b%cc⌋+⌊bc⌋(n+1){b}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n\\lfloor \\frac{a i+b\\% c}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor(n+1) b≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​⌊cai+b%c​⌋+⌊cb​⌋(n+1) 因此 a≥c∣∣b≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n⌊(a%c)i+b%cc⌋+⌊bc⌋(n+1)+⌊ac⌋n×(n+1)2{a}\\geq{c}||{b}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n\\lfloor \\frac{(a\\%c) i+b\\% c}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor(n+1)+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} a≥c∣∣b≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​⌊c(a%c)i+b%c​⌋+⌊cb​⌋(n+1)+⌊ca​⌋2n×(n+1)​ ⇒F(a,b,c,n)=F(a%c,b%c,c,n)++⌊bc⌋(n+1)+⌊ac⌋n×(n+1)2\\Rightarrow F(a,b,c,n) = F(a\\%c,b\\%c,c,n)++\\lfloor\\frac{b}{c}\\rfloor(n+1)+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} ⇒F(a,b,c,n)=F(a%c,b%c,c,n)++⌊cb​⌋(n+1)+⌊ca​⌋2n×(n+1)​ 之后只要解决a&lt;c&amp;&amp;b&lt;ca \\lt c \\&amp;\\&amp; b\\lt ca&lt;c&amp;&amp;b&lt;c的情况就好了（？ 由 ∑i=0n⌊ai+bc⌋=∑i=0n∑j=1⌊ai+bc⌋1=∑i=0n∑j=1⌊an+bc⌋[j≤⌊ai+bc⌋]\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor =\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor \\frac{ai+b}{c}\\rfloor}1 =\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[{j\\leq \\lfloor \\frac{ai+b}{c}\\rfloor}] i=0∑n​⌊cai+b​⌋=i=0∑n​j=1∑⌊cai+b​⌋​1=i=0∑n​j=1∑⌊can+b​⌋​[j≤⌊cai+b​⌋] 交换求和顺序（ ⇒∑j=1⌊an+bc⌋∑i=0n[j≤⌊ai+bc⌋]\\Rightarrow \\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[{j\\leq \\lfloor \\frac{ai+b}{c}\\rfloor}] ⇒j=1∑⌊can+b​⌋​i=0∑n​[j≤⌊cai+b​⌋] 又有 ⌊ab⌋≥c⇔a≥bc\\lfloor \\frac{a}{b} \\rfloor \\geq c \\Leftrightarrow a\\geq bc ⌊ba​⌋≥c⇔a≥bc ⌈ab⌉≤c⇔a≤bc\\lceil \\frac{a}{b} \\rceil \\leq c \\Leftrightarrow a\\leq bc ⌈ba​⌉≤c⇔a≤bc 因此 =∑j=1⌊an+bc⌋∑i=0n[jc≤ai+b]=∑j=1⌊an+bc⌋∑i=0n[⌈jc−ba⌉≤i]=∑j=1⌊an+bc⌋[n+1−⌈jc−ba⌉]=\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[jc\\leq {ai+b}] =\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[\\lceil \\frac{jc-b}{a} \\rceil \\leq i] =\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[n+1-\\lceil \\frac{jc-b}{a} \\rceil] =j=1∑⌊can+b​⌋​i=0∑n​[jc≤ai+b]=j=1∑⌊can+b​⌋​i=0∑n​[⌈ajc−b​⌉≤i]=j=1∑⌊can+b​⌋​[n+1−⌈ajc−b​⌉] =∑j=1⌊an+bc⌋[n+1−⌊jc−b+a−1a⌋]=\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[n+1-\\lfloor \\frac{jc-b+a-1}{a} \\rfloor] =j=1∑⌊can+b​⌋​[n+1−⌊ajc−b+a−1​⌋] =n⌊an+bc⌋−∑j=1⌊an+bc⌋[⌊jc−b+a−1a⌋−1]=n⌊an+bc⌋−∑j=0⌊an+bc⌋−1[⌊(j+1)c−b−1a⌋]=n\\lfloor \\frac{an+b}{c}\\rfloor-\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[\\lfloor \\frac{jc-b+a-1}{a} \\rfloor-1] =n\\lfloor \\frac{an+b}{c}\\rfloor-\\sum_{j=0}^{\\lfloor \\frac{an+b}{c}\\rfloor-1}[\\lfloor \\frac{(j+1)c-b-1}{a} \\rfloor] =n⌊can+b​⌋−j=1∑⌊can+b​⌋​[⌊ajc−b+a−1​⌋−1]=n⌊can+b​⌋−j=0∑⌊can+b​⌋−1​[⌊a(j+1)c−b−1​⌋] 因此我们有a,b&lt;ca,b\\lt ca,b&lt;c时 F(a,b,c,n)=n⌊an+bc⌋−F(c,−1−b+c,a,⌊an+bc⌋−1)F(a,b,c,n)=n\\lfloor \\frac{an+b}{c}\\rfloor-F(c,-1-b+c,a,\\lfloor \\frac{an+b}{c}\\rfloor-1) F(a,b,c,n)=n⌊can+b​⌋−F(c,−1−b+c,a,⌊can+b​⌋−1) 然后就 可以递归了 终止条件a=0 以下代码 123456ll exgcd(ll a, ll b, ll c, ll n)&#123; if(a==0) return (n+1)*(b/c); if(a&gt;=c||b&gt;=c) return exgcd(a%c, b%c, c, n) + floor(a/c)*n*(n+1)/2 + floor(b/c)*(n+1); ll temp = (a*n+b)/c; return n*temp - exgcd(c, c-b-1, a, temp-1);&#125;","categories":[{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"00算法/数学","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://pophirasawa.top/wiki/tags/%E6%95%B0%E8%AE%BA/"}]}],"categories":[{"name":"01学习","slug":"01学习","permalink":"https://pophirasawa.top/wiki/categories/01%E5%AD%A6%E4%B9%A0/"},{"name":"组合数学","slug":"01学习/组合数学","permalink":"https://pophirasawa.top/wiki/categories/01%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"00算法/字符串","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数据结构","slug":"00算法/数据结构","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP","slug":"00算法/DP","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/DP/"},{"name":"数学","slug":"00算法/数学","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/wiki/tags/SAM/"},{"name":"莫队","slug":"莫队","permalink":"https://pophirasawa.top/wiki/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"https://pophirasawa.top/wiki/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"DP","slug":"DP","permalink":"https://pophirasawa.top/wiki/tags/DP/"},{"name":"数论","slug":"数论","permalink":"https://pophirasawa.top/wiki/tags/%E6%95%B0%E8%AE%BA/"}]}