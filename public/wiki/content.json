{"meta":{"title":"PopHirasawa's wiki","subtitle":"循此苦旅，直抵群星。","description":"","author":"PopHirasawa","url":"https://pophirasawa.top/wiki","root":"/wiki/"},"pages":[{"title":"Categories","date":"2022-01-02T00:39:26.087Z","updated":"2022-01-02T00:24:35.060Z","comments":true,"path":"categories/index.html","permalink":"https://pophirasawa.top/wiki/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-01-02T00:24:35.063Z","updated":"2022-01-02T00:24:35.063Z","comments":true,"path":"tags/index.html","permalink":"https://pophirasawa.top/wiki/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2022-01-02T03:21:59.241Z","updated":"2022-01-02T03:21:59.241Z","comments":true,"path":"about/index.html","permalink":"https://pophirasawa.top/wiki/about/index.html","excerpt":"","text":"这个是wiki分页 搞得也太麻烦了 使用文件夹进行分类 装了一个hexo-directory-category"}],"posts":[{"title":"春天春日春色好饿","slug":"02戏言/春天春日春色好饿","date":"2022-04-15T15:17:39.000Z","updated":"2022-04-15T15:18:36.322Z","comments":true,"path":"wiki/02戏言/春天春日春色好饿/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/02%E6%88%8F%E8%A8%80/%E6%98%A5%E5%A4%A9%E6%98%A5%E6%97%A5%E6%98%A5%E8%89%B2%E5%A5%BD%E9%A5%BF/","excerpt":"","text":"“如果有机会的话，请把我埋葬在春光里。” 那个人曾经这么说过。 春天， 鲜花遍地， 细雨如丝， 泥土，卷云，轻柔的风。 澄澈的苍穹，粉色晕染的斜阳。 确实很美呢。 他挥舞着铲子，汗水从龟裂的木制把手上跌落，流进刚刚挖开的新鲜土壤里。 “再等等，就快好了。” 说话的声音很轻，即使凑近也也听不清楚，更何况他的四周空无一人。 他的身边，只有那具早已失去了生机的无言躯体。 这个世界，早已破碎。 连绵的战火，燃烧着天空。 衰败的国度，早已力不从心。 曾经辉煌的文明，大多被埋葬在废墟之下。 魔物，异常，甚至是食人者，大行其道。 我们到底为何而生？ 这个问题没有答案。 甚至回答的余力都没有。 不过，这些和他都没有关系。 只要活下去，就已经足够了。 然而， 就算在这样的世界里， 也依然有花朵盛开。 一年一度。 无论有没有人欣赏， 仅仅， 单纯地随风摇摆着。 “墓志铭的话，我想想，就写‘此处有花’吧。” 那个人是不是曾经这样说过呢？ 他不知道。 泥土随着铲子依旧不断纷飞着。 在某个瞬间， 他感到了一丝异样。 起初只是一点，但是异样的感觉越来越大，让他不得不停下了手中的工作。 到底是为什么呢？ 斜阳渐渐染红了天空。 然后，他终于发现了，异样的源头。 橙红的枫叶缓缓飘入刚刚挖好的坑中。 ——现在是秋天。 他哑然，随即苦笑随着白色的雾气，从肺中吐出。 “边干活边想这种无聊的设定的习惯还是没改掉啊。” “不过，这还是第一次犯了这么严重的错误。”轻声的低语中，带着一丝自嘲。 最重要的是， 他有点饿了。 不过好在快挖的差不多了，胡思乱想也没带来太多麻烦。 将最后一铲土丢在一旁。 坑挖好了。 他将坑底铺满柴火，搭上架子。 饱餐了一顿。 ——就是食材在边上放了太久，有点不新鲜了","categories":[{"name":"02戏言","slug":"02戏言","permalink":"https://pophirasawa.top/wiki/categories/02%E6%88%8F%E8%A8%80/"}],"tags":[]},{"title":"God was a girl","slug":"02戏言/God was a girl","date":"2022-04-09T20:06:33.000Z","updated":"2022-04-10T04:34:44.350Z","comments":true,"path":"wiki/02戏言/God was a girl/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/02%E6%88%8F%E8%A8%80/God%20was%20a%20girl/","excerpt":"","text":"满载着生命种子的火箭缓缓升空，狭长的尾焰闪烁着淡淡的蓝色，在没有大气层的月球表面显得格外清晰。 ——就好像烟花一样。 不知怎地，脑海里突然蹦出了这个词。 「说起来，按照旧人类的历法，今天正好是祭典呢」 打开了布满灰尘的全息投影仪，蓝.AIC投影出了自己的虚拟形象。 蓝色的光线流转，身穿浴衣的少女，身影渐渐清晰。 「下次的话，我也想和故事里面的人们一起，欢笑，烦恼，幸福，流泪」 少女的投影如此自言自语。 我想，成为人类。 「不过，这都是下次的事情了」 电子合成的声音，带着一丝俏皮。 「现在嘛，嘿嘿」 它，或者说她。 双手合十，向着远去的淡蓝色许下了最初亦或者是最后的愿望。 她说， 「要有光」","categories":[{"name":"02戏言","slug":"02戏言","permalink":"https://pophirasawa.top/wiki/categories/02%E6%88%8F%E8%A8%80/"}],"tags":[]},{"title":"视雪症","slug":"02戏言/视雪症","date":"2022-03-27T15:59:43.000Z","updated":"2022-03-27T16:00:22.070Z","comments":true,"path":"wiki/02戏言/视雪症/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/02%E6%88%8F%E8%A8%80/%E8%A7%86%E9%9B%AA%E7%97%87/","excerpt":"","text":"说到雪，你首先会想到什么呢？ 在某次聚会上，曾经有人问过他这个问题。 是川端康成的《雪国》哦，他如此答道，一本由美，浪漫与哀伤构成的书。 欸——，没想到你这么文艺，啥时候也写本书给哥们看看呗。朋友们开始起哄。 笑了笑，他不再说话。 他撒谎了。 其实他根本没有看过《雪国》，首先想到这本书自然也无从说起。 提起雪这个字，第一时间想到的当然是 视雪症。 还有， 她。 他还记得和她相识的第一个下雪天。 那时他刚刚得病不久。 那是一种视觉疾病，具体表现可以大概描述为看见的东西有着仿佛老式电视机的雪花噪点。 试想一下，视野内莫名出现的噪点给整个世界套上了一层怪异的滤镜，曾经记忆中纯净的颜色混入了模糊暧昧的干扰。而这种问题在高亮度的颜色下尤为强烈，甚至能让人无法看清书本上的字。 医生宣读了最后的审判：“这种病的发病机理都不明确，目前无法治疗。只能尝试着去习惯它。” 就算闭上双眼，一片漆黑之中，灰白的雪花也如影随形。 之后的某一天，下雪了。 那天的体育课，老师让大家不用上课，一起玩雪。同学们在操场上嬉笑打闹，充满了青春的欣喜。 大地银装素裹，一片纯白。白色，正是令他症状最严重的颜色。 他坐在被搬到教室门口的凳子上，盯着眼前的一切发呆。 然后， “同学，你怎么啦？” 耳边传来少女的声音。 抬起头，他的心漏跳了一拍。 飞舞的鹅绒中，用白色蝴蝶结扎着低马尾的少女含笑和他对视。 “嘿嘿，我看你一脸忧郁着盯着雪地。有点好奇就来问问。”看着他一时间没有反应，少女带着明媚的笑容说到，“咱这好不容易下雪，不去玩玩可不行啊”。 回过神来，一丝恶作剧的情绪浮现。既然这人这么好奇，如果告诉她我眼睛的毛病会怎么样呢？ 在讲述了自己的境遇后，想象中的安慰和怜悯的话语并没有出现。 “好…” “啊？” “好好听哦，视雪症这个名字。”少女向他伸出了手，“走走走，赶紧去玩雪，待会下课了。” “唉。”他叹了口气，无视了那只手。这人长得这么可爱，怎么是个笨蛋啊。 纯白的雪花依旧缓缓飘落。 寂静且温暖。 他和她一起度过的第二个下雪天，是高中第一个寒假刚刚结束的第一天。 新年刚过几天就要去学校的学生们一觉醒来，发现有点点白色降临人间。不禁有些兴奋。 “新年快乐。” 老师正在讲台上涛涛不绝的时候，他对身边的少女小声说。 “新年快乐。真没想到我们能成同桌呢。”少女面无表情，但是语气中带着一丝高兴。毕竟老师在台上看着，不能笑得太明显啊。 “嘿嘿，新的一年多多指教哦。” 少女向他伸出了手。 这回他没有无视。 春天还没到，教室外寒风将纯白吹地胡乱飘舞。 少女的手温暖而柔软。 只要看见她的笑容，就不会注意到视野里灰白色的雪花了。 他没来由的想。 “说起来，我们还是在下雪天认识的呢。” 某节自习课，少女盯着窗外突然说到。 “是吧，那时候我不是还很讨厌下雪吗。”他停下笔，也看向窗外。什么时候积雪已经这么厚了，真是南方小镇难以遇到的大雪啊。 “那你现在喜欢下雪天吗？”她突然转过头来，嘴角带着一丝坏笑。 喂喂，这可是送命题啊。“那当然是，呃…比较喜欢吧。” “回答地这么不情不愿，还天天看外边下的雪发呆，真是傲娇啊。” “先不提这个词不是这么用的，我现在喜欢下雪是因为我喜欢白色。” “我们认识那天你可不是这么说的哦。” 哼哼，上套了。 他指向少女马尾，“这就是原因。” 思索了片刻，她的脸颊爬上了一抹绯红。“哼~” 然后别过头去。 用白色蝴蝶结扎好的马尾由于惯性甩了过来，却在到他脸上的前一刻缓解了力度，最终化为了温柔的香风。 真是的，到底谁才是傲娇啊。 然而，就算风景再美丽，雪终究是会融化的。 夏天，到了。 他已经记不清缘起为何。是高考考到了不同的城市，让他们分隔异地。还是理想与现实终究无法相互妥协。亦或者是她根本就不存在？ 某一天起，他们没有再见过面。 曾经美好的回忆已经渐渐模糊。 到最后，就算是记忆中少女的脸，也不甚清楚。 视野里的灰色雪花，已经延伸到了过去。 但是曾经和她在一起，他已经习惯了自己的病。 只是时不时还是会想起少女的微笑。 又是一年寒假。 他在家乡的道路上行走。 耳边传来熟悉的声音，沉睡的记忆渐渐复苏。 他猛然抬头，看见一个似曾相识的少女。 以及某个在藏在记忆深处，被锁在珍贵宝箱中的明媚笑容。 一如既往。 他们的视线相交了一瞬，又各自离开。 少女展现笑容的对象，不是自己。 等二人走过，他也没有回头。但是他瞥见了少女马尾根部，白色的蝴蝶结。 叹了口气，他继续走着。 视野内，侵入点点白色。 下雪了。","categories":[{"name":"02戏言","slug":"02戏言","permalink":"https://pophirasawa.top/wiki/categories/02%E6%88%8F%E8%A8%80/"}],"tags":[]},{"title":"鸽巢原理","slug":"01学习/组合数学/鸽巢原理","date":"2022-01-09T17:10:00.000Z","updated":"2022-01-19T03:04:47.489Z","comments":true,"path":"wiki/01学习/组合数学/鸽巢原理/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/01%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86/","excerpt":"内容 鸽巢原理及其一些推论，包括但不限于 简单形式 中国剩余定理 加强形式 Ramesy定理 呃呃","text":"内容 鸽巢原理及其一些推论，包括但不限于 简单形式 中国剩余定理 加强形式 Ramesy定理 呃呃 简单形式 n+1个物品放入n个盒子中，至少存在一个盒子中存在多个物品 可以抽象表示为: 令X，Y为两有限集，令f为一个从X到Y的函数 若X的元素大于Y的元素，则f不是一对一的 若X和Y有相同个数的元素，且f是映上的，则f是一对一的 若X和Y有相同个数的元素，且f是一对一的，则f是映上的 然后就可以发展出一些应用了 推论：中国剩余定理 令m和n为互素的正整数，有正整数a、b，且a不大于m-1，b不大于n-1。则存在x，x mod m = a，x mod n = b。 证明：先得出在a，a+m，a+2m，…(n-1)m+a中mod n没有相同的余数。因此n个数中0到n-1每个数都作为余数出现。那对与b也存在对应的p令pm+a mod n = b Ramsey定理 在6个人中，或有三个人他们彼此互相都认识，或有三个人，他们中两两都彼此不认识。 也就是说： 考虑一个6个点的无向完全图，将边染成两种颜色。那么必定存在一个三角形三条边为相同的颜色。 也可以表示为K6→K3,K3也可以表示为K_6\\rightarrow K_3,K_3 也可以表示为K6​→K3​,K3​ 更一般的定义如下： m，n为两个不小于2的整数，那么将存在一个正整数p，令$$K_P \\rightarrow K_m,K_n$$ Ramsey数r(m,n)为令等式成立的最小整数p 有定理 r(2,n)=n以及r(m,2)=m 可以往更高维推广。。。","categories":[{"name":"01学习","slug":"01学习","permalink":"https://pophirasawa.top/wiki/categories/01%E5%AD%A6%E4%B9%A0/"},{"name":"组合数学","slug":"01学习/组合数学","permalink":"https://pophirasawa.top/wiki/categories/01%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"tags":[]},{"title":"0X00","slug":"Homepage","date":"2022-01-01T16:00:00.000Z","updated":"2022-01-02T03:05:53.684Z","comments":true,"path":"wiki/Homepage/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/Homepage/","excerpt":"","text":"Hello！ 这里应该是wiki吧… 也是一个在hexo里边塞两种不同主题的尝试 好像貌似大概可能是成功了 所有这里放的应该是一些应该放到的wiki里边的东西 芜湖~","categories":[],"tags":[]},{"title":"后缀自动机","slug":"00算法/字符串/sam","date":"2021-11-19T18:08:36.000Z","updated":"2022-01-03T13:35:02.386Z","comments":true,"path":"wiki/00算法/字符串/sam/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/00%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/sam/","excerpt":"这玩意就是SAM的原理以及基本板子了，大概，说不定再来一点套路总结吧 总的来说，这玩意拖的也太久了，一直说要学，然后狂摸不止，我 有罪！ 欸嘿","text":"这玩意就是SAM的原理以及基本板子了，大概，说不定再来一点套路总结吧 总的来说，这玩意拖的也太久了，一直说要学，然后狂摸不止，我 有罪！ 欸嘿 介绍 首先后缀自动机 可以包括给定字符串的所有子串 O(n) 是自动机 一些定义 endpos 字符串s的一个子串t，endpos(t)为s中t的所有结束位置构成的集合 SAM是一个最小的DFA 有向无环图 节点是状态，边是转移 转移是一些字母 从源点出发到终止状态所有转移连起来的字符串t是字符串s的一个后缀 SAM的节点最小 那么如果endpos(t1)=endpos(t2)，那么他们就在一个等价类中 一堆引理 两个非空子串u，w (|u|&lt;=|w|) endpos相同，只有u在s中每次出现都是以w的后缀出现的 那么就可以推出来： 考虑u，w (|u|&lt;=|w|) 只有2种可能 endpos(u),endpos(w)不相交 endpos(w)是endpos(u)的子集 一个endpos等价类里边，所有子串长度不同，而且差值为1，正好覆盖区间 然后就有我们的后缀link 对于一个不是源点的状态v，然后考虑这个endpos等价类中最长的字符串w，其他的就是w后缀了捏 然后我们有 w开始，有一个连续区间长度的后缀也都是这个等价类里边的玩意，定义最长的一个不是等价类里边的后缀为t，把v的后缀link到t上 显然最后是link到源点的 最后这玩意就构成了一个树 然后我们就可以开始算法本身了捏 算法实现 哥们看不懂捏 首先说重点 后缀link树和后缀自动机共同相同的节点，不同的只是转移的边不同 大概步骤 首先，这个是在线算法，我们每次往自动机里加入一个字符，然后维护SAM 首先定义初始状态 这个点编号0，len=0，fa=0 然后我们就能挨个加入字符c了 有以下流程 首先我们加入了一个新字符，那么新串对应的的endpos是新的长度，以前不存在，因此我们新建一个状态np，之前整个旧串对应的状态记为p，很显然len(q)=len§+1 然后对于新加入的字符c，我们进行以下操作 如果p没有一个字符c的出边(这里是自动机的边)，就在link树上到他的父节点，也就是后缀link的点，一直循环直到p到达初始状态的节点或者有一个字符c的出边 这个操作其实是压缩遍历旧串的所有后缀x，然后看是否存在一个x+c在旧串种就存在了，因为引理中已经提到，每个状态link到的节点都是当前状态的后缀，所有我们从p上来肯定是旧串的后缀了捏 途中我们把经过每个没有c出边的p都连一个c到np 然后我们就有3种情况 Case 1 p到初始状态都没有c的出边 np状态直接link到初始状态 Case 2 找到了一个p，有c的出边，到达一个新状态q，且len( q )=len( p )+1 首先我们知道p是旧串后缀，q是p的字符串+c，因此q是新串的后缀，那么我们理所当然把np link 到q上就行了 Case 3 和case2差不多，但是找到的p出边到达的q没有len( q )=len( p )+1 或者说，len( q )&gt;len( q )+1 这时候我们要把q拆成两个点，是新串后缀的和不是的，然后link就行 具体来说，定义一个新点nq，len=len§+1,出边转移和q相同，link 到p上，然后np和q都link到nq上 最后稍微更新下转移边，p往上走，把所有p link 到q的转移 link 到nq上就行了 最后稍微提一下如何计算每个状态的endpos大小 设想一下，我们每次加入一个字符c，肯定会出现一个新的endpos，而且他能够对往上走到源点经过的所有节点都产生影响，也就是说我们使用一个数组f[i]来统计endpos，加入新字符时让f[np]=1,最后跑一下dfs，f[i]=f[i]+sum(f[i所有的儿子]) 即可捏 或者把sam的点按len排序(可以用桶排) 从大到小更新 **f[sam[i].fa]+=f[i]**也行 code 先贴一手毛的板子 1234567891011121314151617181920212223242526struct NODE&#123; int ch[26]; int len,fa; NODE()&#123;memset(ch,0,sizeof(ch));len=0;&#125;&#125;sam[MAXN&lt;&lt;1];int lst=1,tot=1;void add(int c)&#123; int p=lst;int np=lst=++tot; sam[np].len=sam[p].len+1; for(;p&amp;&amp;!sam[p].ch[c];p=sam[p].fa)sam[p].ch[c]=np; if(!p)sam[np].fa=1;//以上为case 1 else &#123; int q=sam[p].ch[c]; if(sam[q].len==sam[p].len+1)sam[np].fa=q;//以上为case 2 else &#123; int nq=++tot;sam[nq]=sam[q]; sam[nq].len=sam[p].len+1; sam[q].fa=sam[np].fa=nq; for(;p&amp;&amp;sam[p].ch[c]==q;p=sam[p].fa)sam[p].ch[c]=nq;//以上为case 3 &#125; &#125;&#125; 暂时先写这么多，乏了，早上写一手题以及用法吧","categories":[{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"00算法/字符串","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/wiki/tags/SAM/"}]},{"title":"维护区间众数","slug":"00算法/数据结构/维护区间众数","date":"2021-11-10T09:32:12.000Z","updated":"2022-01-03T13:34:45.948Z","comments":true,"path":"wiki/00算法/数据结构/维护区间众数/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/00%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E4%BC%97%E6%95%B0/","excerpt":"这玩意好像方法挺多的，然后今天被一个阴间东西坑了，来说一哈 其实就是给一个数列，然后给一堆询问，问你区间众数是多少吧","text":"这玩意好像方法挺多的，然后今天被一个阴间东西坑了，来说一哈 其实就是给一个数列，然后给一堆询问，问你区间众数是多少吧 首先先把我之前的复制一手啊 绝对众数问题 就是出现个数超过n/2的众数 这个我们可以用一个摩尔投票的方法来写捏 摩尔投票 首先考虑一个序列，里面两两取数，如果一样就留下，不一样就两个数都消掉，那么最后留下的数肯定就是数量超过n/2的数 实现的话，用两个变量cur和cnt，如果当前的数和cur不同且cnt==0 cur变为当前数，否则cnt– 如果相同 cnt++ 最后cur就是唯一有可能是绝对众数的数，然后跑一遍确认即可 123456789101112ll dat[maxn];ll majorityElement()&#123; ll cnt=1,cur=dat[0]; for(int i=1;i&lt;n;i++)&#123; if(dat[i]!=cnt)cnt--; else cnt++; if(cnt&lt;0)&#123; cut=dat[i]; cnt=0; &#125; &#125;&#125; 如果是n/3以至于n/k 其实就是设置多组cur和cnt就行 然后我们就能用线段树来维护了捏 线段树维护 无论如何产生的绝对众数唯一可能就是左右子区间cur中的一个 如果cur1==cur2 新的区间cur3=cur1 ，cnt3=cnt1+cnt2 如果不同 cur3为两段中cnt较大的一个，且cnt3为两段之差 然后查的时候只要查出来cur然后跑一遍二分查区间内个数就能确定了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct node&#123; ll num, c;&#125;;ll n, q, k;node dat[300001&lt;&lt;2];ll a[300000 + 5];ll l, r;vector&lt;ll&gt; pos[300000 + 5];node merge(node x, node y) &#123; if (x.num == y.num) return(x.num, x.c + y.c); else if (x.c &lt; y.c) return&#123; y.num,y.c - x.c &#125;; else return &#123; x.num,x.c - y.c &#125;;&#125;void pushup(ll o) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; dat[o] = merge(dat[ls], dat[rs]);&#125;void build(ll o, ll l, ll r) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (l == r) &#123; dat[o] = &#123; a[l],1 &#125;; return; &#125; ll m = l + r &gt;&gt; 1; build(ls, l, m); build(rs, m + 1, r); pushup(o);&#125;node ask(ll o, ll l, ll r, ll p, ll q) &#123; ll ls = o &lt;&lt; 1, rs = o &lt;&lt; 1 | 1; if (p&lt;= l &amp;&amp; q &gt;= r)return dat[o]; ll m = l + r &gt;&gt; 1; if (q &lt;= m)return ask(ls, l, m, p, q); if (p &gt; m)return ask(rs, m + 1, r, p, q); return merge(ask(ls, l, m, p, q), ask(rs, m + 1, r,p, q));&#125;int main() &#123; cin.sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n&gt;&gt;q; srand(time(NULL)); ll tmp; for (int i = 1; i &lt;=n; i++) &#123; cin &gt;&gt; a[i]; pos[a[i]].push_back(i); &#125; build(1, 1, n); for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; l &gt;&gt; r; ll tmp=ask(1, 1, n, l, r).num; ll ans = upper_bound(pos[tmp].begin(), pos[tmp].end(), r) - lower_bound(pos[tmp].begin(), pos[tmp].end(), l); &#125;&#125; 一般的众数 这玩意方法就可多了，这里讲一个今天把我坑麻了的莫队写法捏 我们开两个数组，cnt[]和num[]，cnt[i]是单纯统计区间里边 i 的出现次数，num[i]统计出现了 i 次的数有多少个。 然后ans就应该是令num[i]不为0的最大的i 考虑到每次更新数的时候，我们其实只会影响一个点的cnt[]和num[]，因此ans只会加1或者减1，因此可以在O(1)的时间内更新捏 那么add和del函数就能这样写了 1234567891011121314151617ll cnt[MAXN], num[MAXN];ll anss = 0;void add(ll x) &#123; ll p = dat[x]; num[cnt[p]]--; cnt[p]++; num[cnt[p]]++; anss = max(anss, cnt[p]);&#125;void del(ll x) &#123; ll p = dat[x]; num[cntt[p]]--; if (anss == cntt[p] &amp;&amp; !num[anss])anss--; --cntt[p]; num[cntt[p]]++;&#125; 本废物因为莫队学的太烂了，以至于没有想到可以用 while(l&lt;=r)del(l++) 手动清零，天天用memset()，T到了天荒地老 小朋友们千万不要学哦","categories":[{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"00算法/数据结构","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"https://pophirasawa.top/wiki/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"https://pophirasawa.top/wiki/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"单调队列优化多重背包","slug":"00算法/DP/单调队列优化dp","date":"2021-11-05T03:13:57.000Z","updated":"2022-01-02T03:20:37.163Z","comments":true,"path":"wiki/00算法/DP/单调队列优化dp/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/00%E7%AE%97%E6%B3%95/DP/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/","excerpt":"补题补到了个树上背包，然后发现孩子不会。这次就打算把一些该学的背包都学一手？大概。 我们知道，对于多重背包，有一个二进制拆分优化，可以在O(vlog(∑n[i]))O(vlog(\\sum{n[i]}))O(vlog(∑n[i]))级别的复杂度解决问题 然后单调队列优化可以跑到O(nv)O(nv)O(nv)","text":"补题补到了个树上背包，然后发现孩子不会。这次就打算把一些该学的背包都学一手？大概。 我们知道，对于多重背包，有一个二进制拆分优化，可以在O(vlog(∑n[i]))O(vlog(\\sum{n[i]}))O(vlog(∑n[i]))级别的复杂度解决问题 然后单调队列优化可以跑到O(nv)O(nv)O(nv) 思路 首先我们考虑一下朴素的多重背包写法： 对于当前物品i，枚举选的个数n[i]，用于更新dp数组 然后我们能够发现这样一个神必规律： dp[i]用于维护代价为i的最大价值，且当前考虑选的物品代价为v 则dp[i]只能够从dp[j]，当且仅当j mod v == i mod v 且选的个数不超过要求的点转移过来 也就是 当前在选第i个物品时 dp[j+nv]=max(dp[j+(n−1)v+w,dp[j+(n−2)v+2w,....)dp[j+nv]=max(dp[j+(n-1)v+w,dp[j+(n-2)v+2w,....) dp[j+nv]=max(dp[j+(n−1)v+w,dp[j+(n−2)v+2w,....) 改变一下形式 dp[j+nv]=max(dp[j],dp[j+v]−w,dp[j+2v]−2w,...)+nwdp[j+nv]=max(dp[j],dp[j+v]-w,dp[j+2v]-2w,...)+nw dp[j+nv]=max(dp[j],dp[j+v]−w,dp[j+2v]−2w,...)+nw 当然，因为有个数的限制，他选定的是一定区间里边的最大值，这个就给我们跑单调区间留下了伏笔捏 CODE 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include&lt;bitset&gt;#include&lt;map&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;ll N, V;ll f[20000 + 5];ll g[20000 + 5];ll q[20000 + 5];int main() &#123; cin &gt;&gt; N &gt;&gt; V; for (int i = 0; i &lt; N; i++) &#123; ll v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; memcpy(g, f, sizeof(f)); for (int j = 0; j &lt; v; j++) &#123; ll l = 0, r = -1; for (int k = j; k &lt;= V; k += v) &#123; while (r &gt;= l &amp;&amp; (k - q[l]) &gt; s * v)l++;// 判断区间长度是否超过 while (r &gt;= l &amp;&amp; (g[q[r]] - (q[r] - j) / v * w) &lt; (g[k] - (k - j) / v * w))r--; q[++r] = k; f[k] = max(g[k], g[q[l]] + (k - q[l]) / v * w); &#125; &#125; &#125; ll ans = 0; for (int i = 0; i &lt;= V; i++)ans = max(f[i], ans); cout &lt;&lt; ans;&#125;","categories":[{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"00算法/DP","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/DP/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://pophirasawa.top/wiki/tags/DP/"}]},{"title":"EXGCD","slug":"00算法/数学/类&拓展欧几里得","date":"2021-10-29T16:00:00.000Z","updated":"2022-01-03T13:34:54.789Z","comments":true,"path":"wiki/00算法/数学/类&拓展欧几里得/","link":"","permalink":"https://pophirasawa.top/wiki/wiki/00%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/%E7%B1%BB&%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"EXGCD 用于解形如ax+by=gcd（a，b）方程的通解","text":"EXGCD 用于解形如ax+by=gcd（a，b）方程的通解 12345678910111213void exgcd(int &amp;x,int &amp;y,int a,int b)&#123; if(!b) &#123; x=1; y=0; return; &#125; exgcd(x,y,b,a%b); int t=x; x=y; y=t-a/b*y;&#125; 也可以解出ax+by=c gcd（a，b）|c的解 上方参数还是gcd（a，b） 解出后x2=x*c/gcd（a，b） y2=y*c/gcd（a，b） 通解为： {(x, y) | x = x2 + k * b / gcd(a, b)， y = y2 - k * a / gcd(a, b), k ∈ z} 特别的 gcd（a，b）等于1时 相当于求ax=1（modb） 为a在b下的逆元（不用b是质数） 解出x后用 x=（x%b+b）%b求出在0-b范围内的x即为逆元 类欧几里得 当我们要计算形如 ∑i=0n⌊ai+bc⌋ \\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor i=0∑n​⌊cai+b​⌋ 且a，b&gt;=0,c&gt;0时 可以使用类欧算法。 首先有以下公式 ⌈ab⌉=⌊a+b−1b⌋\\lceil \\frac{a}{b}\\rceil = \\lfloor \\frac{a+b-1}{b}\\rfloor ⌈ba​⌉=⌊ba+b−1​⌋ ⌊ab⌋=⌈a−b+1b⌉\\lfloor\\frac{a}{b}\\rfloor = \\lceil \\frac{a-b+1}{b}\\rceil ⌊ba​⌋=⌈ba−b+1​⌉ 挺容易推的：关于1式，如果 a % b != 0,那么右边就会比左边大1，2式原理相同。 然后开始推（？ 我们令 F(a,b,c,n)=∑i=0n⌊ai+bc⌋F(a,b,c,n)=\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor F(a,b,c,n)=i=0∑n​⌊cai+b​⌋ a≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n(⌊a%c×i+bc⌋+⌊ac⌋i)=∑i=0n⌊a%c×i+bc⌋+⌊ac⌋n×(n+1)2{a}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n(\\lfloor \\frac{a\\%c\\times i+b}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor i)=\\sum_{i=0}^n\\lfloor \\frac{a\\%c\\times i+b}{c}\\rfloor+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} a≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​(⌊ca%c×i+b​⌋+⌊ca​⌋i)=i=0∑n​⌊ca%c×i+b​⌋+⌊ca​⌋2n×(n+1)​ b≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n⌊ai+b%cc⌋+⌊bc⌋(n+1){b}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n\\lfloor \\frac{a i+b\\% c}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor(n+1) b≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​⌊cai+b%c​⌋+⌊cb​⌋(n+1) 因此 a≥c∣∣b≥c⇒∑i=0n⌊ai+bc⌋=∑i=0n⌊(a%c)i+b%cc⌋+⌊bc⌋(n+1)+⌊ac⌋n×(n+1)2{a}\\geq{c}||{b}\\geq{c}\\Rightarrow\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor=\\sum_{i=0}^n\\lfloor \\frac{(a\\%c) i+b\\% c}{c}\\rfloor+\\lfloor\\frac{b}{c}\\rfloor(n+1)+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} a≥c∣∣b≥c⇒i=0∑n​⌊cai+b​⌋=i=0∑n​⌊c(a%c)i+b%c​⌋+⌊cb​⌋(n+1)+⌊ca​⌋2n×(n+1)​ ⇒F(a,b,c,n)=F(a%c,b%c,c,n)++⌊bc⌋(n+1)+⌊ac⌋n×(n+1)2\\Rightarrow F(a,b,c,n) = F(a\\%c,b\\%c,c,n)++\\lfloor\\frac{b}{c}\\rfloor(n+1)+\\lfloor\\frac{a}{c}\\rfloor\\frac{n\\times (n+1)}{2} ⇒F(a,b,c,n)=F(a%c,b%c,c,n)++⌊cb​⌋(n+1)+⌊ca​⌋2n×(n+1)​ 之后只要解决a&lt;c&amp;&amp;b&lt;ca \\lt c \\&amp;\\&amp; b\\lt ca&lt;c&amp;&amp;b&lt;c的情况就好了（？ 由 ∑i=0n⌊ai+bc⌋=∑i=0n∑j=1⌊ai+bc⌋1=∑i=0n∑j=1⌊an+bc⌋[j≤⌊ai+bc⌋]\\sum_{i=0}^n\\lfloor \\frac{ai+b}{c}\\rfloor =\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor \\frac{ai+b}{c}\\rfloor}1 =\\sum_{i=0}^n\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[{j\\leq \\lfloor \\frac{ai+b}{c}\\rfloor}] i=0∑n​⌊cai+b​⌋=i=0∑n​j=1∑⌊cai+b​⌋​1=i=0∑n​j=1∑⌊can+b​⌋​[j≤⌊cai+b​⌋] 交换求和顺序（ ⇒∑j=1⌊an+bc⌋∑i=0n[j≤⌊ai+bc⌋]\\Rightarrow \\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[{j\\leq \\lfloor \\frac{ai+b}{c}\\rfloor}] ⇒j=1∑⌊can+b​⌋​i=0∑n​[j≤⌊cai+b​⌋] 又有 ⌊ab⌋≥c⇔a≥bc\\lfloor \\frac{a}{b} \\rfloor \\geq c \\Leftrightarrow a\\geq bc ⌊ba​⌋≥c⇔a≥bc ⌈ab⌉≤c⇔a≤bc\\lceil \\frac{a}{b} \\rceil \\leq c \\Leftrightarrow a\\leq bc ⌈ba​⌉≤c⇔a≤bc 因此 =∑j=1⌊an+bc⌋∑i=0n[jc≤ai+b]=∑j=1⌊an+bc⌋∑i=0n[⌈jc−ba⌉≤i]=∑j=1⌊an+bc⌋[n+1−⌈jc−ba⌉]=\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[jc\\leq {ai+b}] =\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}\\sum_{i=0}^n[\\lceil \\frac{jc-b}{a} \\rceil \\leq i] =\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[n+1-\\lceil \\frac{jc-b}{a} \\rceil] =j=1∑⌊can+b​⌋​i=0∑n​[jc≤ai+b]=j=1∑⌊can+b​⌋​i=0∑n​[⌈ajc−b​⌉≤i]=j=1∑⌊can+b​⌋​[n+1−⌈ajc−b​⌉] =∑j=1⌊an+bc⌋[n+1−⌊jc−b+a−1a⌋]=\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[n+1-\\lfloor \\frac{jc-b+a-1}{a} \\rfloor] =j=1∑⌊can+b​⌋​[n+1−⌊ajc−b+a−1​⌋] =n⌊an+bc⌋−∑j=1⌊an+bc⌋[⌊jc−b+a−1a⌋−1]=n⌊an+bc⌋−∑j=0⌊an+bc⌋−1[⌊(j+1)c−b−1a⌋]=n\\lfloor \\frac{an+b}{c}\\rfloor-\\sum_{j=1}^{\\lfloor \\frac{an+b}{c}\\rfloor}[\\lfloor \\frac{jc-b+a-1}{a} \\rfloor-1] =n\\lfloor \\frac{an+b}{c}\\rfloor-\\sum_{j=0}^{\\lfloor \\frac{an+b}{c}\\rfloor-1}[\\lfloor \\frac{(j+1)c-b-1}{a} \\rfloor] =n⌊can+b​⌋−j=1∑⌊can+b​⌋​[⌊ajc−b+a−1​⌋−1]=n⌊can+b​⌋−j=0∑⌊can+b​⌋−1​[⌊a(j+1)c−b−1​⌋] 因此我们有a,b&lt;ca,b\\lt ca,b&lt;c时 F(a,b,c,n)=n⌊an+bc⌋−F(c,−1−b+c,a,⌊an+bc⌋−1)F(a,b,c,n)=n\\lfloor \\frac{an+b}{c}\\rfloor-F(c,-1-b+c,a,\\lfloor \\frac{an+b}{c}\\rfloor-1) F(a,b,c,n)=n⌊can+b​⌋−F(c,−1−b+c,a,⌊can+b​⌋−1) 然后就 可以递归了 终止条件a=0 以下代码 123456ll exgcd(ll a, ll b, ll c, ll n)&#123; if(a==0) return (n+1)*(b/c); if(a&gt;=c||b&gt;=c) return exgcd(a%c, b%c, c, n) + floor(a/c)*n*(n+1)/2 + floor(b/c)*(n+1); ll temp = (a*n+b)/c; return n*temp - exgcd(c, c-b-1, a, temp-1);&#125;","categories":[{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"00算法/数学","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://pophirasawa.top/wiki/tags/%E6%95%B0%E8%AE%BA/"}]}],"categories":[{"name":"02戏言","slug":"02戏言","permalink":"https://pophirasawa.top/wiki/categories/02%E6%88%8F%E8%A8%80/"},{"name":"01学习","slug":"01学习","permalink":"https://pophirasawa.top/wiki/categories/01%E5%AD%A6%E4%B9%A0/"},{"name":"组合数学","slug":"01学习/组合数学","permalink":"https://pophirasawa.top/wiki/categories/01%E5%AD%A6%E4%B9%A0/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"00算法","slug":"00算法","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"00算法/字符串","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数据结构","slug":"00算法/数据结构","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP","slug":"00算法/DP","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/DP/"},{"name":"数学","slug":"00算法/数学","permalink":"https://pophirasawa.top/wiki/categories/00%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"https://pophirasawa.top/wiki/tags/SAM/"},{"name":"莫队","slug":"莫队","permalink":"https://pophirasawa.top/wiki/tags/%E8%8E%AB%E9%98%9F/"},{"name":"线段树","slug":"线段树","permalink":"https://pophirasawa.top/wiki/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"DP","slug":"DP","permalink":"https://pophirasawa.top/wiki/tags/DP/"},{"name":"数论","slug":"数论","permalink":"https://pophirasawa.top/wiki/tags/%E6%95%B0%E8%AE%BA/"}]}